<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="">
    <meta name="description" content="">
    <title>修改文档</title>
    <link href="css/bootstrap.css" rel="stylesheet" />
    <link href="css/style.css" rel="stylesheet" />
</head>
<body>
<div class="bg-grey PLR40">

    <div class="paper-txt P30 PB0">
        <div class="alert alert-success" role="alert">此为您在“详细报告”中修改后临时保存的内容，编辑过的内容会变绿色</div>
        <p class="text-idt25" data-id="1">摘要</p><p class="text-idt25" data-id="2">随着移动互联网的迅速发展， SOC作为便携式智能终端的信息处理能力和待机时间的要求也日趋提高，存储器作为 SOC的重要组成，一般而言面积占整个 SOC芯片面积的一半以上，尤其在高性能处理器中， SRAM占芯片的面积已经超过80%。存储器的性能对SOC芯片的影响很大。</p><p class="text-idt25" data-id="3">如今的 SRAM设计中，越来越多的低功耗技术和高速技术被提出，比如 DVFS技术、电荷泵技术等，在诸多优化技术带来诸多便利的同时， SRAM的设计周期相应也延长了，尤其在仿真环节中，相比于原本就耗时的 SRAM设计仿真周期而言，这些优化技术无疑也增加了仿真周期和设计周期。</p><p class="text-idt25" data-id="4">本文主要内容和研究对象是：第一，介绍机器学习，详细阐述了最小二乘法回归算法；第二，介绍了标准单元库，分析了十个标准单元的时序，通过电路参数建模实现时序预测和通过时序建模实现时序预测；第三，介绍 SRAM的电路结构、基本原理和特征化，主要对表征中的时序和功耗进行分析，并通过时序建模实现时序预测、按温度划分功耗实现功耗预测；第四，分析并指出本方法在SRAM设计周期中对于设计周期和仿真周期的提升效果。</p><p class="text-idt25" data-id="5">关键词：标准单元库静态随机存取存储器最小二乘法编译器表征预测</p><p class="text-idt25" data-id="6">第一章绪论</p><p class="text-idt25" data-id="7">1.1.1半导体集成电路介绍</p><p class="text-idt25" data-id="8">随着移动互联网和物联网的发展，集成电路芯片广泛应用于各种领域，如手机，PC，可穿戴设备等，其中手机的出货量已经超过71亿。如今空前辉煌的电子信息产业链，是以六十多年来集成电路的发展为基础的。</p><p class="text-idt25" data-id="9">2017年全球集成电路产品的市场销售额大约在4000亿美元左右，其所撬动的电子信息产业的产值为15万亿美元，已然超过全球GDP的五分之一。</p><p class="text-idt25" data-id="10">国际半导体产业协会（SEMI）发布的各家产业研究机构对2018年半导体产业营收的预测成长率为7～8%。在全球集成电路发展的浪潮中，我国集成电路行业也有不错的表现，中国在智能手机为代表的移动终端的 AP、通信模块方面已占据全球大约17%的市场份额，但是在应用集成电路的其他领域，国产芯片所占市场比例几乎为零。从国内的集成电路规模来看，我国集成电路产业正进入快速发展期，并将以一个近20%的增长率持续增长，2017年产值已达到5000多亿。但是国内集成电路仅30%左右是自给，其余依赖于进口，其进口额已然超过石油成为第一大进口商品，这种现状亟待解决。</p><p class="text-idt25" data-id="11">在经济方面，不论是国内还是全球，发展集成电路都有着重要的意义。</p><p class="text-idt25" data-id="12">1.1.2存储器及SRAM介绍</p><p class="text-idt25" data-id="13">图1-1SOC中存储器的使用情况</p><p class="text-idt25" data-id="14">存储器作为现在 VSLI中重要的组成部分，随着近年来半导体技术的发展，存储器在 SoC上占据越来越重要的比重，如今存储器面积已经达到 SoC的80%，而 SRAM作为存储器的重要角色，亦具有十分重要的意义。</p><p class="text-idt25" data-id="15">存储器的种类繁多，分类性质也很多，因为存取方式的不同，可以分为随机存取存储器（ Random Access Memory）、顺序存取存储器（ Serial Access Memory）和按内容寻址存储器（ Content Access Memory）。</p><p class="text-idt25" data-id="16">随机存取存储器根据断电后能够继续保存信息而分类，可以分为易失性存储器（VM）和非易失性存储器（NVM）两类。通常易失性存储器又分为静态随机存取存储器（SRAM）和动态随机存取存储器（DRAM）。</p><p class="text-idt25" data-id="17">SRAM是最广泛应用的存储器之一，主要用两个交叉耦合的反相器存储数据，只要电源不断电，数据就一直被保存。</p><p class="text-idt25" data-id="18">当今SOC处理器的主频已经达到4GHZ，片外大容量主存储器的频率只有600MHZ左右。SRAM凭借面积小，容量合适，速度快和很好的鲁棒性等优势，作为SOC芯片的存储设备。 SRAM的速度可以向逻辑电路那么快，完全可以满足处理器的主频需求，在待机的状态下功耗较低，具有更高的带宽，可以满足系统对带宽的需求。更好的工艺缩放性，可以随着工艺节点的缩小得到更好的集成度和性能。SRAM在拥有这些其他存储器不可比拟的优势的同时，也意味着SRAM具备的设计难度和要求。</p><p class="text-idt25" data-id="19">1.1.3SRAM设计优化技术</p><p class="text-idt25" data-id="20">早在1973年，戈登摩尔曾指出，一个硅片上晶体管的数量每隔18个月就翻一番（摩尔定律）。在过去的几十年中，集成电路行业的发展一直印证着摩尔定律，一颗芯片上的晶体管数量一直保持大约每两年翻一番。随着晶体管数量的剧增，能耗问题、散热问题变得日益严重。其中，低功耗已经成为集成电路设计的重要指标。</p><p class="text-idt25" data-id="21">目前工业界常用的低功耗设计手段有门控时钟（ Clock Gating）、电源关断（ Power Shut- off）、多阈值电压（ Multi- Vth）、多电源电压（ Multi- Supply Voltage）、动态电压频率调节（ DVFS， Dynamic Voltage and Frequency Scaling）、衬底电压偏置（ Substrate Biasing）等。其中门控时钟是较为常用的降低动态功耗的设计手段。该设计手段通过使能信号控制时钟传播来降低芯片的动态功耗，它需要引入新的设计单元，因此一个信号控制的寄存器数量越多，控制层次也相应越高。电源关断则是通过使能信号控制一个区域的电源来降低芯片的泄漏功耗。当使能信号无效时，整个区域不供电，因此不产生泄漏功耗。需要注意的是，这种设计方法需要引入较多的开关单元和控制单元，而且在供电网络上插入控制单元会在使能信号的开关瞬间对周围区域的逻辑器件造成电压波动，因此在引入该方法的分析、验证上必须仔细考虑。多阈值电压通过将不同阈值电压器件混合使用来降低芯片的泄漏功耗。多电源电压则是在芯片的不同区域根据需求选用不同的电源电压值，它可以在降低动态功耗的同时降低静态功耗。多电源电压、动态电压调节（DVS）、以及动态电压频率调节技术都是通过调节电源电压达到降低功耗的目的。多电源电压是静态电压调整方法，不同的电源电压对应不同的工作性能和功耗。DVS和DVFS则是自适应性的方法，他们通过识别处理器的利用率工作：当处理器负载较轻时，降低频率和电压；当处理器满负荷工作时，系统在最大频率和电压条件下运行。这些技术己被广泛应用于商用微处理器，有着显著的节能特性。</p><p class="text-idt25" data-id="22">动态电压频率调整技术（ DVFS）是根据芯片所运行的应用程序对计算能力的不同需要，动态的调整芯片不同模块的运行频率和电压，从而达到节能的目的。</p><p class="text-idt25" data-id="23">文献11中3 D图形处理中有三个独立的模块，每个模块有不同的性能需求，将不同的三个模块应用 DVFS技术可以实现每个功率区域的高效的能耗减少。最终，GPU系统产生相同输出结果的同时，应用DVFS技术的电源管理比正常工作的电源管理实现节省功率约65%。</p><p class="text-idt25" data-id="24">在各种层次的低功耗技术广泛应用在 SRAM设计的时候，在带来显著减少功耗的同时，也给 SRAM设计提出了相应的附属要求，以 DVFS为例，不同模块动态调整工作电压和工作频率，对于设计的要求，尤其是仿真的要求提高了很多。通常SRAM编译器都有几千个实例，对于某个实例都要在不同的PVT（Process、Voltage、Temperature）进行仿真。DVFS使得SOC的电压节点增加了很多。以TSMC 28nm HPCPLUS为例，标准电压是0.9v，相对应的SRAM的签出需要6个PVT的仿真。电压节点从0.72v到1.08v时，以90mv为间隔，一共需要30个corner的签出。</p><p class="text-idt25" data-id="25">以50个 Intel（ R） Xeon的4核 CPU，其频率为3.60 GHZ，以及足够的 EDA licenses， Memory Compiler的表征仿真需要约340小时，基于机器资源和时间成本的考虑，以及更多优化技术的加入，未来 SRAM compiler表征所需的仿真将会呈现阶梯式的增长。本课题的出发点就是提出利用机器学习算法，通过已知的仿真数据构建模型，去预测未知的仿真数据，从而实现节省机器资源和减少时间成本的目的，进而优化整个 SRAM compiler的设计效率。</p><p class="text-idt25" data-id="26">1.3论文的主要内容</p><p class="text-idt25" data-id="27">本文主要基于当今微电子行业对于机器学习的应用现状与前景，总结了机器学习在存储器设计中应用的可行性与可靠性，确立了本文的课题：基于机器学习的28nm工艺SRAM Compiler特征化。围绕这一主题，基于 SRAM编译器的设计现状，针对仿真过程的耗时长、占用资源比重大等不足，提出了应用机器学习算法简化仿真，并先后在标准单元库和 SRAM compiler的设计中应用，以期对未来的机器学习应用于集成电路设计的重要环节中有一定的指导意义。</p><p class="text-idt25" data-id="28">本文的主要内容如下：</p><p class="text-idt25" data-id="29">第一章为绪论，主要介绍了 SRAM compiler的研究背景、意义，系统阐述了机器学习应用于 SRAM compiler的应用现状和发展前景，并对本文的研究方法做了总结概括。</p><p class="text-idt25" data-id="30">第二章首先简单的介绍了机器学习及其发展现状与应用前景，主要阐述了回归算法，着重分析了最小二乘法和支持向量机的算法原理和应用场景。</p><p class="text-idt25" data-id="31">第三章介绍了标准单元库及其时序，并通过支持向量机算法，拟合已有的时序数据，预测未知的时序数据。</p><p class="text-idt25" data-id="32">第四章介绍了SRAM compiler的设计流程，着重描述了表征的三个模块：时序、功耗和电容，并对三个模块分别使用最小二乘法进行数据的预测。</p><p class="text-idt25" data-id="33">第五章为总结与展望，对本文的工作进行了总结，并对本课题的研究进行了展望。</p><p class="text-idt25" data-id="34">第二章最小二乘法</p><p class="text-idt25" data-id="35">2.1机器学习</p><p class="text-idt25" data-id="36">2.1.1 机器学习的定义</p><p class="text-idt25" data-id="37">机器学习（ Machine Learning）是一门人工智能的学科，它所讨论的是在从有限观察概括特定问题世界模型的机器学习也从有限观察发现观测数据中暗含的各种关系的数据分析的方法，其领域的主要研究对象是人工智能，研究热点是如何在经验学习中改善具体算法的性能。机器学习主要应用于数据挖掘、语音和手写识别、计算机视觉、生物特征识别、自然语言处理、医学诊断、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、 DNA序列测序、证券市场分析、战略游戏和机器运用等领域。</p><p class="text-idt25" data-id="38">2.1.2 机器学习的发展史</p><p class="text-idt25" data-id="39">20世纪90年代初期，当时的美国副总统提出了一个重要的计划：国家信息基本设施计划（National Information Infrastructure）。这个计划的技术含义主要包含了四个方面内容：</p><p class="text-idt25" data-id="40">1．不分时间与地域，可以方便地获得信息。</p><p class="text-idt25" data-id="41">2．不分时间与地域，可以有效地利用信息。</p><p class="text-idt25" data-id="42">3．不分时间与地域，可以有效地利用软硬件资源。</p><p class="text-idt25" data-id="43">4．保证信息安全。</p><p class="text-idt25" data-id="44">信息有效利用问题的本质是：如何根据用户特定的需求从海量的数据中建立适当的模型或者发现有用的知识。对计算机科学来言，这就是机器学习。机器学习作为人工智能领域较为年轻的分支，它的发展历程大致上可分为四个时期[40] [43]。</p><p class="text-idt25" data-id="45">第一阶段是从20世纪50年代中叶到60年代中叶，属于热烈时期。</p><p class="text-idt25" data-id="46">第二阶段是从20世纪60年代中叶至70年代中叶，被称为机器学习的冷静时期。</p><p class="text-idt25" data-id="47">第三阶段是从20世纪70年代中叶至80年代中叶，称为复兴时期。</p><p class="text-idt25" data-id="48">机器学习的最新阶段始于1986年。机器学习开启进入新阶段的主要表现在下列几个方面：</p><p class="text-idt25" data-id="49">1．机器学习已成为新兴的热门学科，并在高校形成一门课程。它综合了应用心理学、数学、自动化、生物学、神经生理学和计算机科学形成机器学习理论基础。</p><p class="text-idt25" data-id="50">2．结合多种学习方法，以取长补短等多种形式的形成的集成学习系统研究正在兴起。特别是连接学习和符号学习的耦合能够更好地解决连续性信号处理中知识与技能的获取与求精问题而受到重视。</p><p class="text-idt25" data-id="51">3．人工智能和机器学习的各种基础问题的统一性的观点正在形成。比如问题求解和学习相结合进行、知识表达使得学习的观点发生了通用智能系统的模块学习。类比学习和问题求解结合的基于示例方法已成为经验学习的一个重要方向。</p><p class="text-idt25" data-id="52">4．随着各种学习方法的应用范围不断拓宽，一部分方法已经形成了商品。归纳学习的知识获取工具已在诊断分类型专家系统中广泛的使用。其中连接学习在声图文的识别应用中占优势；而分析学习已经用于设计综合型的专家系统；另外，强化学习和遗传算法在工程控制应用中有很好的应用前景；最后与符号系统耦合的神经网络方法已经在智能机器人运动规划和企业的智能管理中发挥着重要作用。</p><p class="text-idt25" data-id="53">5．机器学习的学术会议空前繁多。国际上除每年一次的机器学习研讨会外，还有遗传算法会议以及计算机学习理论会议等。</p><p class="text-idt25" data-id="54">2.1.3 机器学习分类</p><p class="text-idt25" data-id="55">机器学习有很多算法，分类方式也有多种。主要的分类方式有基于学习策略的分类、按应用领域分类、基于所获取知识的表示形式分类、学习形式分类和综合分类等。其中最为普遍接受的是按学习形式分类。</p><p class="text-idt25" data-id="56">机器学习按学习形式分类有监督学习（Supervised Learning）、非监督学习（Unsupervised Learning）和强化学习等几种类型。实践中应用较多的也就是监督学习和非监督学习。</p><p class="text-idt25" data-id="57">监督学习就是数据样本会告诉计算机在该情形下的正确输出结果，希望计算机能够在面对没有见过的输入样本时也给出正确的输出结果，从而达到预测未知的目的。</p><p class="text-idt25" data-id="58">根据输出结果是离散还是连续，监督学习可以分为分类问题和回归问题两大类。他们在文字、语音、图像识别、垃圾邮件分类与拦截、网页检索、股票预测等方面有着广泛应用。</p><p class="text-idt25" data-id="59">非监督学习是指数据样本中没有给出正确的输出结果信息。无监督学习希望从数据中挖掘的正是这一类信息，常见的例子有聚类、关联规则挖掘、离群点检测等等。</p><p class="text-idt25" data-id="60">强化学习是智能系统从环境到行为映射的学习，以使奖励信号（强化信号）函数值最大，强化学习不同于连接主义学习中的监督学习，主要表现在强化学习中由环境提供的强化信号是对产生动作的好坏作一种评价（通常为标量信号），而不是告诉强化学习系统 RLS（ Reinforcement Learning System）如何去产生正确的动作。由于外部环境提供的信息很少，RLS必须靠自身的经历进行学习。通过这种方式，RLS在行动评价的环境中获得知识，改进行动方案以适应环境。</p><p class="text-idt25" data-id="61">2.2最小二乘法回归</p><p class="text-idt25" data-id="62">2.2.1线性回归模型</p><p class="text-idt25" data-id="63">考虑到本课题中数据的多维性，这里用多元回归方程表示：</p><p class="text-idt25" data-id="64">=</p><p class="text-idt25" data-id="65">0</p><p class="text-idt25" data-id="66">+</p><p class="text-idt25" data-id="67">1</p><p class="text-idt25" data-id="68">1</p><p class="text-idt25" data-id="69">+</p><p class="text-idt25" data-id="70">2</p><p class="text-idt25" data-id="71">2</p><p class="text-idt25" data-id="72">++</p><p class="text-idt25" data-id="73">式中：i称为假设模型即映射输入特征x与结果y的线性函数h的参数（Parameters），为了简化表示，我们在输入特征中加入X0=1 ，于是得到：</p><p class="text-idt25" data-id="74">=</p><p class="text-idt25" data-id="75">=0</p><p class="text-idt25" data-id="76">=</p><p class="text-idt25" data-id="77">参数和输入特征x都为矢量，n是输入的特征x的个数（不包含x0）。</p><p class="text-idt25" data-id="78">使得预测值 h( x)尽可能接近 y，为了达到这个目的，我们对于每一个参数，定义一个代价函数（ Cost Function）用来描述 h( x( i))’与对应的 y( i)’的接近程度：</p><p class="text-idt25" data-id="79">=</p><p class="text-idt25" data-id="80">1</p><p class="text-idt25" data-id="81">2</p><p class="text-idt25" data-id="82">=0</p><p class="text-idt25" data-id="83">(</p><p class="text-idt25" data-id="84">0</p><p class="text-idt25" data-id="85">(</p><p class="text-idt25" data-id="86">()</p><p class="text-idt25" data-id="87">)</p><p class="text-idt25" data-id="88">)</p><p class="text-idt25" data-id="89">2</p><p class="text-idt25" data-id="90">于是我们的目标就变为了调整使得代价函数J()取得最小值，方法有梯度下降法，最小二乘法等。</p><p class="text-idt25" data-id="91">2.2.2 最小二乘法</p><p class="text-idt25" data-id="92">最小二乘法是一种直观的直接利用矩阵运算可以得到值的算法。</p><p class="text-idt25" data-id="93">假设函数f是将m*n维矩阵映射为一个实数的运算，即</p><p class="text-idt25" data-id="94">Function :</p><p class="text-idt25" data-id="95">并且定义对于矩阵A，映射f(A)对A的梯度为：</p><p class="text-idt25" data-id="96">=</p><p class="text-idt25" data-id="97">11</p><p class="text-idt25" data-id="98">1</p><p class="text-idt25" data-id="99">1</p><p class="text-idt25" data-id="100">因此该梯度为m*n的矩阵。</p><p class="text-idt25" data-id="101">另外，对于矩阵的迹的梯度运算，有如下规则：</p><p class="text-idt25" data-id="102">=</p><p class="text-idt25" data-id="103">()=</p><p class="text-idt25" data-id="104">(</p><p class="text-idt25" data-id="105">())</p><p class="text-idt25" data-id="106">=</p><p class="text-idt25" data-id="107">+</p><p class="text-idt25" data-id="108">=</p><p class="text-idt25" data-id="109">(</p><p class="text-idt25" data-id="110">1</p><p class="text-idt25" data-id="111">)</p><p class="text-idt25" data-id="112">下面，我们将测试集中的输入特征x和对应的结果y表示成矩阵或者向量的形式，有：</p><p class="text-idt25" data-id="113">=</p><p class="text-idt25" data-id="114">1</p><p class="text-idt25" data-id="115">2</p><p class="text-idt25" data-id="116">=</p><p class="text-idt25" data-id="117">(1)</p><p class="text-idt25" data-id="118">(2)</p><p class="text-idt25" data-id="119">()</p><p class="text-idt25" data-id="120">对于预测模型有：</p><p class="text-idt25" data-id="121">=</p><p class="text-idt25" data-id="122">=0</p><p class="text-idt25" data-id="123">=</p><p class="text-idt25" data-id="124">，</p><p class="text-idt25" data-id="125">即：</p><p class="text-idt25" data-id="126">=</p><p class="text-idt25" data-id="127">1</p><p class="text-idt25" data-id="128">，</p><p class="text-idt25" data-id="129">于是可以很容易得到：</p><p class="text-idt25" data-id="130">=</p><p class="text-idt25" data-id="131">1</p><p class="text-idt25" data-id="132">1</p><p class="text-idt25" data-id="133">=</p><p class="text-idt25" data-id="134">1</p><p class="text-idt25" data-id="135">1</p><p class="text-idt25" data-id="136">所以可以得到：</p><p class="text-idt25" data-id="137">1</p><p class="text-idt25" data-id="138">2</p><p class="text-idt25" data-id="139">=</p><p class="text-idt25" data-id="140">1</p><p class="text-idt25" data-id="141">2</p><p class="text-idt25" data-id="142">=1</p><p class="text-idt25" data-id="143">(</p><p class="text-idt25" data-id="144">(</p><p class="text-idt25" data-id="145">()</p><p class="text-idt25" data-id="146">)</p><p class="text-idt25" data-id="147">)</p><p class="text-idt25" data-id="148">2</p><p class="text-idt25" data-id="149">=</p><p class="text-idt25" data-id="150">于是，我们就将代价函数J()表示为了矩阵的形式，就可以用上述提到的矩阵运算来得到梯度：</p><p class="text-idt25" data-id="151">=</p><p class="text-idt25" data-id="152">1</p><p class="text-idt25" data-id="153">2</p><p class="text-idt25" data-id="154">=</p><p class="text-idt25" data-id="155">1</p><p class="text-idt25" data-id="156">2</p><p class="text-idt25" data-id="157">(</p><p class="text-idt25" data-id="158">+</p><p class="text-idt25" data-id="159">)</p><p class="text-idt25" data-id="160">=</p><p class="text-idt25" data-id="161">1</p><p class="text-idt25" data-id="162">2</p><p class="text-idt25" data-id="163">+</p><p class="text-idt25" data-id="164">=</p><p class="text-idt25" data-id="165">1</p><p class="text-idt25" data-id="166">2</p><p class="text-idt25" data-id="167">2</p><p class="text-idt25" data-id="168">=</p><p class="text-idt25" data-id="169">1</p><p class="text-idt25" data-id="170">2</p><p class="text-idt25" data-id="171">+</p><p class="text-idt25" data-id="172">2</p><p class="text-idt25" data-id="173">=</p><p class="text-idt25" data-id="174">令上述梯度为0，得到等式：</p><p class="text-idt25" data-id="175">=</p><p class="text-idt25" data-id="176">，</p><p class="text-idt25" data-id="177">于是得到的值：</p><p class="text-idt25" data-id="178">=(</p><p class="text-idt25" data-id="179">)</p><p class="text-idt25" data-id="180">1</p><p class="text-idt25" data-id="181">。</p><p class="text-idt25" data-id="182">这就是最小二乘法得到的假设模型中参数的值。</p><p class="text-idt25" data-id="183">2.3 算法实现</p><p class="text-idt25" data-id="184">2.3.1 Python语言简介</p><p class="text-idt25" data-id="185">Python语言诞生于20世纪90年代初，它已被逐渐广泛应用于Web编程和系统管理任务的处理等领域[22]。Python语言是一个高层次的结合了编译性、解释性、互动性和面向对象的脚本编程语言。Python语言具有诸多特点：易于学习、数据库GUI编程、易于阅读、广泛的标准库、易于维护、可扩展性、交互式、可移植、可嵌入等优势。 Python语言凭借着自身的诸多优势，广泛应用于系统编程、数据挖掘、图形处理、数学处理、黑客编程、文本处理、网络编程、数据库编程、 Web编程和多媒体应用等领域或方向。</p><p class="text-idt25" data-id="186">Python语言区别于其他的编程语言还有一个特点：具有丰富和强大的库，并能够把用其他语言制作的各种模块联结起来。最常见的一种应用情形：将Python快速生成原型程序，然后将其中有特别配置的部分，用更合适的语言编写。比如3 D游戏中的图形渲染的模块对于性能要求特别高，这时候就可以用 C++重写，然后再将其封装为 Python语言可以调用的扩展类库。</p><p class="text-idt25" data-id="187">除了自己编写程序模块之外，众多开源的科学计算软件包也提供了Python的调用接口。比如著名的计算机视觉库OpenCV、医学图像处理库ITK和三维可视化库VTK。而Python专用的科学计算扩展库也有很多。比如经典的科学计算扩展库：SciPy、NumPy和Matplotlib，它们分别为Python提供了数值运算、快速数组处理以及绘图功能。本论文使用这三个标准库，其中更主要的使用了面向机器学习的Scikit-learn标准模块库。</p><p class="text-idt25" data-id="188">2.3.2 Scikit-learn</p><p class="text-idt25" data-id="189">Scikit-learn是一个开源的基于Python语言的科学计算工具包。它基于SciPy，针对不同的应用领域已经发展了很多的分支版本，它们统一称为Scikits，就是SciPy工具包的意思。在这些分支版本中，最著名的也是专门面向机器学习的一个就是Scikit-learn。 Scikit- learn最早由数据科学家 David Cournapeau在2007年提出，它依赖于 NumPy和 SciPy等程序包的支持，是 Python语言中面向机器学习应用开发的一款开源框架[24]。</p><p class="text-idt25" data-id="190">Scikit-learn的基本功能分为六大部分：分类、回归、聚类、数据降维、模型选择和数据预处理。</p><p class="text-idt25" data-id="191">（1）分类是辨别对象所属的类别，是监督学习的一种。最常见的应用包括垃圾邮件识别和图像识别等应用。目前Scikit-learn所包含的算法有：支持向量机（SVM）、最近邻、随机森林、逻辑回归、决策树以及神经网络等等。另外由于Scikit-learn本身不支持深度学习，也不支持GPU加速。</p><p class="text-idt25" data-id="192">（2）回归是指预测给定对象相关联的连续值的问题，其中最常见的应用场景包括预测药物反应和预测股票价格等问题。目前Scikit-learn已经包含的算法有：支持向量回归（SVR）、弹性网络（Elastic Net）、脊回归（Ridge）、Lasso回归、最小角回归（LARS）和贝叶斯等回归算法。</p><p class="text-idt25" data-id="193">（3）聚类则是指自动识别具有相似属性的对象的问题。聚类属于无监督学习的典型，最常见的应用场景主要包括顾客类型细分和试验结果分组等问题。目前Scikit-learn已经包含的算法有：K-均值聚类、均值偏移、谱聚类、分层聚类和DBSCAN聚类等算法。</p><p class="text-idt25" data-id="194">（4）数据降维指的是用主成分分析（ PCA）、特征选择和非负矩阵分解（ NMF）等降维算法来减少需要考虑的随机变量个数，其主要应用场景包括效率提升和可视化处理等问题。</p><p class="text-idt25" data-id="195">（5）模型选择的主要内容是对于给定的模型和参数的比较、验证和选择。模型选择的主要目的是通过参数的调整来提升精度。目前Scikit-learn所包含的模块有：交叉验证、格点搜索和各种预测误差评估的度量函数。</p><p class="text-idt25" data-id="196">（6）数据预处理的主要内容是数据的归一化和特征提取，这是所有的机器学习过程中的首要也是最重要的一个环节。归一化是将输入数据转换为具有零均值和单位权方差的变量。虽然大多数时候都做不到精确等于零，但是往往会设置一个可接受的范围，一般都要求落在0～1之间。特征提取所做的是将图像数据和文本数据转换为可用于机器学习的数值变量。</p><p class="text-idt25" data-id="197">总结以上六点来说， Scikit- learn实现了完整用于数据降维、模型选择、特征提取和归一化的完整算法模块，同时还提供了每个算法和模块以及其丰富的参考样例和详细的说明文档。</p><p class="text-idt25" data-id="198">本文中主要使用了Scikit-learn的回归、模型选择和数据预处理等多个模块。</p><p class="text-idt25" data-id="199">本文中最小二乘方法主要通过Python、C++等编程语言实现，本文中数据的收集整理主要通过Linux C Shell和Python语言实现。</p><p class="text-idt25" data-id="200">第三章 28nm标准单元库时序预测</p><p class="text-idt25" data-id="201">3.1 标准单元库</p><p class="text-idt25" data-id="202">3.1.1标准单元方法</p><p class="text-idt25" data-id="203">在半导体设计中，标准单元方法（Standard Cell Methodology）是一种用于专用集成电路（Application Specific Integrated Circuits，ASICs）的数字逻辑的设计方法。标准单元方法可以将一个低级的超大规模集成电路（Very-Large-Scale Integration，VSLI）的版图封装成一个抽象的逻辑表示形式，比如与非门。这就可以让电路设计师更专注于数字设计，而其他的设计师更专注于物理设计。随着半导体制造业的进步，标准单元方法使得成千上万的逻辑功能相对简单的电路，得以缩放到复杂的百万门级的SOC上。</p><p class="text-idt25" data-id="204">标准单元是通过晶体管通过组合互联构成具有布尔逻辑函数，比如AND、OR、XOR、XNOR等，存储单元，比如Flip-Flop和Latch。最简单的标准单元比如NAND、NOR、XOR等布尔逻辑功能，尽管更为常用的是一些复杂的布尔逻辑单元：全加器，D触发器等。标准单元的布尔逻辑功能就是它的逻辑视图，其逻辑行为通常表现为真值表、布尔代数方程和状态转换表。，其中布尔代数方程通常用于组合逻辑，状态转换表通常用于顺序逻辑。</p><p class="text-idt25" data-id="205">通常，标准单元的初始设计开发在晶体管级，以晶体管网表或电路的视图的形式。网表是晶体管、晶体管连接、端口与外部电路连接的节点描述。电路图一般都是通过一些计算机辅助设计（ Computer aided design， CAD）和电子设计自动化（ Electronic design automation， EDA）的程序提供的图形化界面（ Graphical User Interface， GUI）来表示。</p><p class="text-idt25" data-id="206">标准单元除了有数字逻辑的表示，版图（ layout）作为最接近实际产品的视图，是由基础层（ layer）组成的，基础层对应晶体管的不同结构，布线层（ wiring layers）和通过层（ via layer）相互连接，然后连接晶体管端口形成的。</p><p class="text-idt25" data-id="207">最后，布局和线路（ PNR）工具可以用来组合的一切，合成的超大规模集成电路的布局，以自动化的方式，从更高层次设计的网表和平面图。</p><p class="text-idt25" data-id="208">此外，还可以使用许多其他CAD工具来验证单元格视图和模型的其他方面。和其他文件可以创建支持各种工具，利用标准细胞过多的其他原因。为支持所有标准单元变化而创建的所有这些文件统称为标准单元库。</p><p class="text-idt25" data-id="209">3.1.2标准单元库</p><p class="text-idt25" data-id="210">表3-1标准单元库的分类</p><p class="text-idt25" data-id="211">标准单元库</p><p class="text-idt25" data-id="212">组合逻辑单元</p><p class="text-idt25" data-id="213">Inverter反相器</p><p class="text-idt25" data-id="214">NAND、NOR 与非、或非门</p><p class="text-idt25" data-id="215">AND、OR 与、或逻辑</p><p class="text-idt25" data-id="216">BUFFER 缓冲器</p><p class="text-idt25" data-id="217">MUX 多路选择器</p><p class="text-idt25" data-id="218">XOR、XNOR 异或、同或逻辑</p><p class="text-idt25" data-id="219">AOI、OAI 与或非、或与非</p><p class="text-idt25" data-id="220">ADD 加法器包括全加器、半加器</p><p class="text-idt25" data-id="221">Clock Cell 包括Clock BUFFER、Clock Inverter、Clock NAND等</p><p class="text-idt25" data-id="222">时序逻辑单元</p><p class="text-idt25" data-id="223">Flip-Flop 触发器</p><p class="text-idt25" data-id="224">LATCH 锁存器</p><p class="text-idt25" data-id="225">特殊类型单元</p><p class="text-idt25" data-id="226">FILL cells 填充单元</p><p class="text-idt25" data-id="227">Tie High、Tie Low cells 电源连接单元</p><p class="text-idt25" data-id="228">Delay cells 信号延迟单元</p><p class="text-idt25" data-id="229">二极管单元</p><p class="text-idt25" data-id="230">Tap cells 阱连接单元</p><p class="text-idt25" data-id="231">FDCAP cells 去耦合单元</p><p class="text-idt25" data-id="232">低功耗辅助设计单元</p><p class="text-idt25" data-id="233">Clock Gating 单元</p><p class="text-idt25" data-id="234">Power Gating单元</p><p class="text-idt25" data-id="235">Isolation Cell 隔离单元</p><p class="text-idt25" data-id="236">Retention Cell 信号保持单元</p><p class="text-idt25" data-id="237">Level Shift 电平转换单元</p><p class="text-idt25" data-id="238">Always-on 单元</p><p class="text-idt25" data-id="239">Well Bias Cell 阱电位偏置单元</p><p class="text-idt25" data-id="240">不仅不同工艺尺寸都会有不同的标准单元库，有时相同的工艺尺寸都会有不同的多套标准单元库供用户选择，它们在不同的电路密度和速度上有着相应的优势。例如中芯国际（ SMIC）深亚微米制程下就包括一套高性能的超高速 VHS（ Very High Speed）单元库、一套密度和速度优化的高速 HS（ High Speed）单元库和一套高密度 HD（ High Density）单元库。</p><p class="text-idt25" data-id="241">一般而言，标准单元库中包含以下四大类单元：组合逻辑单元、时序逻辑单元、特殊类型单元和PMK（Power Management Kit）低功耗辅助设计逻辑单元。</p><p class="text-idt25" data-id="242">3.1.3 标准单元库流程</p><p class="text-idt25" data-id="243">传统标准单元库建立的流程如图：</p><p class="text-idt25" data-id="244">图3-1标准单元库建立流程</p><p class="text-idt25" data-id="245">制定设计方案：在设计设计28nm标准单元之前，我们首先要制定设计方案。主要包括：1）需要设计的单元库器件，2）标准单元库的高度（ track数），3）在版图中版面两单元间的中心距距离（ Pitch），4） MOSFET中 PMOS与 NMOS的宽度比，5）单元库器件的驱动能力</p><p class="text-idt25" data-id="246">单元电路设计：合理设计出所需要的全部库单元的电路结构和器件尺寸，同时单元的功能和时序也需要通过SPICE等工具进行的相关的验证。</p><p class="text-idt25" data-id="247">单元版图设计：绘制出所有库单元的版图，并使其满足面积最小，同时所有的电路单元保持高度一致。版图验证主要通过DRC（Design Rule Check）和LVS（Layout Versus Schematic）这两步的验证。其次，还需要根据Foundry所提供的Design Rule进行物理特性的验证。</p><p class="text-idt25" data-id="248">库模型建立：一套完整的标准单元库仅包含电路和版图是不够的，还必须包含各种符合国际标准的可被EDA工具识别的库模型文件。对于后端设计师而言，使用各种EDA工具，利用Foundry提供的文件，对标准单元库进行仿真、验证。这些库文件主要描述了单元的时序信息、版图信息和网表信息三个方面。</p><p class="text-idt25" data-id="249">表3-2库模型文件分类</p><p class="text-idt25" data-id="250">时序信息文件</p><p class="text-idt25" data-id="251">.lib</p><p class="text-idt25" data-id="252">标准单元的Synopsis的时序模型，描述了标准单元的时间、功率特性</p><p class="text-idt25" data-id="253">.db</p><p class="text-idt25" data-id="254">.lib的二进制格式文件</p><p class="text-idt25" data-id="255">.tlf</p><p class="text-idt25" data-id="256">标准单元的TT、FF、SS工艺角的时序库文件</p><p class="text-idt25" data-id="257">版图信息文件</p><p class="text-idt25" data-id="258">.lef</p><p class="text-idt25" data-id="259">供布局布线使用的版图文件格式，具有工艺信息和各个单元的几何特性的文件，是生成milkyway库所必需的</p><p class="text-idt25" data-id="260">.gdsii</p><p class="text-idt25" data-id="261">包含版图信息的文件</p><p class="text-idt25" data-id="262">网表信息文件</p><p class="text-idt25" data-id="263">.cdl</p><p class="text-idt25" data-id="264">标准单元网表，用于LVS检查</p><p class="text-idt25" data-id="265">.v</p><p class="text-idt25" data-id="266">Verilog语言格式文件</p><p class="text-idt25" data-id="267">.vhd</p><p class="text-idt25" data-id="268">VHDL语言格式文件</p><p class="text-idt25" data-id="269">符号库文件</p><p class="text-idt25" data-id="270">.slib</p><p class="text-idt25" data-id="271">标准单元的符号库文件</p><p class="text-idt25" data-id="272">库验证：标准单元库必须通过 Foundry的可制造性验证，同时还要确保标准单元库模型的正确性以及应用库模型设计出来的电路在制造出来后时序、功耗、面积多能满足要求。</p><p class="text-idt25" data-id="273">Release：设计并验证标准单元库之后，还需要撰写标准单元库的设计报告、使用手册、数据手册、等相关文档，方便Foundry使用，并将相关资料整理打包。</p><p class="text-idt25" data-id="274">3.2 时序</p><p class="text-idt25" data-id="275">3.2.1 Liberty库</p><p class="text-idt25" data-id="276">LIB时序库主要用于描述每个标准单元的基本逻辑功能、延迟时间参数等，其中延迟时间参数是通过投片测试或仿真提取获得的。 LIB是由 Synopsys公司开发的专门用于描述物理单元的时序以及功耗方面的信息的关键库文件内容，一般情况下， LIB文件有库的基本属性和标准单元的具体信息两个部分组成。</p><p class="text-idt25" data-id="277">基本属性主要描述了标准单元库的基本信息，主要包含 PVT corner（ Process、 Voltage、 Temperature）、文件的版本号、生成日期、电路属性、器件类型、以及时序功耗的查找表等。主要用于利用这些单元的功能参数库可以进行电路的Verilog/VHDL数字仿真，确定所设计电路的功能正确与否，检查异步时序电路中的竞争和冒险等工作。</p><p class="text-idt25" data-id="278">图3-2LIB文件中功耗数值查询表</p><p class="text-idt25" data-id="279">LIB文件的主要部分是每个标准单元的功能和有关的延迟参数，主要包括亚阈值电流、输入输出负载以及时序功耗的数值查询表。</p><p class="text-idt25" data-id="280">如图是UMC 28nm工艺的TT1.05V25C下的标准单元库的LIB文件的INV的功耗查询表。</p><p class="text-idt25" data-id="281">其中rise_power表示管脚A从0变为1的内部功耗，但不包含开关功耗，开关功耗有电容乘以电压的平方单独运算；index_1表示输入的传输时间；index_2表示输出端电容；values就是当输入输出取不同值时，相对应的内部功耗值。其中横坐标是index_1，纵坐标是index_2。</p><p class="text-idt25" data-id="282">图3-3LIB文件中时序数值查询表</p><p class="text-idt25" data-id="283">如图是UMC 28nm工艺的TT1.05V25C下的标准单元库的LIB文件的INV的时序查询表（部分）。</p><p class="text-idt25" data-id="284">其中timing就是标准单元的时序描述；cell_fall是下降时间；fall_transition是传输时间；index_1是输入的传输时间；index_2是输出端的电容；values是77的时序查询表，横坐标是index_1，纵坐标是index_2。</p><p class="text-idt25" data-id="285">LIB文件包含的时序信息是非常繁多的，详见公式：</p><p class="text-idt25" data-id="286">LIB数=阈值电压沟道长度时序模型工艺角电压温度</p><p class="text-idt25" data-id="287">以UMC28nmHLP工艺的标准单元库而言，LIB数由以下元素组成。</p><p class="text-idt25" data-id="288">表3-3LIB文件数的影响因素详表</p><p class="text-idt25" data-id="289">阈值电压</p><p class="text-idt25" data-id="290">沟道长度</p><p class="text-idt25" data-id="291">（纳米）</p><p class="text-idt25" data-id="292">时序模型</p><p class="text-idt25" data-id="293">工艺角</p><p class="text-idt25" data-id="294">电压</p><p class="text-idt25" data-id="295">（V）</p><p class="text-idt25" data-id="296">温度</p><p class="text-idt25" data-id="297">（）</p><p class="text-idt25" data-id="298">RVT</p><p class="text-idt25" data-id="299">LVT</p><p class="text-idt25" data-id="300">HVT</p><p class="text-idt25" data-id="301">30</p><p class="text-idt25" data-id="302">35</p><p class="text-idt25" data-id="303">40</p><p class="text-idt25" data-id="304">NLDM</p><p class="text-idt25" data-id="305">CCS</p><p class="text-idt25" data-id="306">ECSM</p><p class="text-idt25" data-id="307">FF</p><p class="text-idt25" data-id="308">FFG</p><p class="text-idt25" data-id="309">TT</p><p class="text-idt25" data-id="310">SS</p><p class="text-idt25" data-id="311">SSG</p><p class="text-idt25" data-id="312">0.855</p><p class="text-idt25" data-id="313">0.90</p><p class="text-idt25" data-id="314">0.945</p><p class="text-idt25" data-id="315">1.05</p><p class="text-idt25" data-id="316">1.15</p><p class="text-idt25" data-id="317">-40</p><p class="text-idt25" data-id="318">0</p><p class="text-idt25" data-id="319">25</p><p class="text-idt25" data-id="320">85</p><p class="text-idt25" data-id="321">125</p><p class="text-idt25" data-id="322">其中，时序模型分为三种：</p><p class="text-idt25" data-id="323">NLDM：非线性延时电压源，适用于40nm以上，LIB文件较小；</p><p class="text-idt25" data-id="324">CCS：复合电流源模型，由Synopsys公司开发，适用于40nm以下，时序更为精准，LIB文件较大；</p><p class="text-idt25" data-id="325">ECSM：有效电流源模型，有Cadence公司开发，适用于40nm以下，时序更为精准，LIB文件中等。</p><p class="text-idt25" data-id="326">由此可以看出，一套标准单元库会包含数量繁多的LIB文件，大约有1425个LIB文件。</p><p class="text-idt25" data-id="327">与此同时，单个LIB文件中具有整个标准单元库的所有电路的时序信息，当阈值电压为HVT，沟道长度是30nm时，就有939个标准单元电路。</p><p class="text-idt25" data-id="328">由此可见，对于标准单元库而言，</p><p class="text-idt25" data-id="329">3.2.2 数据收集</p><p class="text-idt25" data-id="330">由于制造工艺的偏差，同一晶圆的芯片在同一环境下都有不同的工作状态。以 MOSFET晶体管为例，尽管他们也有类似的电阻和电容，会有不同的状态，如 FNFP、 SNSP、 TNTP、 FNSP、 SNFP，不同的阈值电压等参数。除了制作工艺的偏差，MOSFET晶体管的性能也受到电压和温度的影响。一般来说，仿真的时候会选择不同的温度节点和工作电压节点。</p><p class="text-idt25" data-id="331">表中有325套Process Corner。</p><p class="text-idt25" data-id="332">表3-4PVT的选择范围</p><p class="text-idt25" data-id="333">工艺</p><p class="text-idt25" data-id="334">FNFP、SNSP、TNTP、FNSP、SNFP</p><p class="text-idt25" data-id="335">电压（V）</p><p class="text-idt25" data-id="336">0.84 0.875 0.91 0.945 0.98 1.015 1.05 1.085 1.12 1.155 1.19 1.225 1.26</p><p class="text-idt25" data-id="337">温度（）</p><p class="text-idt25" data-id="338">-40 -0 25 85 125</p><p class="text-idt25" data-id="339">本课题选取了十个电路分别是：INV、AND2、AND3、NOR2B、NOR2、AOI211、XOR3、ADDF、DFFNQ、DFFNSRPQ。</p><p class="text-idt25" data-id="340">本章仿真均使用基于Bsim4仿真模型的H-Spice仿真工具，Slew设置为1ns。</p><p class="text-idt25" data-id="341">以D触发器为例，输入端是D，输出端是Q。路径延时（ Path Delay）定义为从输入波形的50%到输出波形的90%或者从输入波形的50%到输出波形的10%，以确保输出波形的电势能稳定达到目标电位。</p><p class="text-idt25" data-id="342">图说明setup time是时钟达到之前波形需要保持一段时间，hold time是时钟达到之后波形需要保持的一段时间。</p><p class="text-idt25" data-id="343">以DFFs为例，setup time是从D端到节点m的传输路径时间，hold time有两个值：一个是节点m到节点s的传输路径时间，另一个是D端到节点nm的传输路径时间。Hold time选取二者的最大值。</p><p class="text-idt25" data-id="344">图3-4传输路径延时：从输入波形50%到输出波形10%的传输路径延时</p><p class="text-idt25" data-id="345">图3-5D触发器的setup time和hold time</p><p class="text-idt25" data-id="346">图3-6D触发器的逻辑电路图</p><p class="text-idt25" data-id="347">本课题中的10个标准单元电路分别有不同数量的路径延迟，D触发器还拥有建立时间和保持时间。</p><p class="text-idt25" data-id="348">对于单输入电路而言，以INV为例，当输入端是上升沿时，输出端是下降沿，具有一个路径延时；当输入端是下降沿时，输出端是上升沿，还具有一个路径延时。</p><p class="text-idt25" data-id="349">对于多输入电路而言，当某一输入端翻转，而其他输入端保持电平不变，且输出端也翻转的时候，才具有一个路径延时。</p><p class="text-idt25" data-id="350">图3-7AND2输入输出波形示意图</p><p class="text-idt25" data-id="351">以AND2为例，时序包含四种时序：</p><p class="text-idt25" data-id="352">当输入A为1时，输入B从0翻转到1时，输出Y从0翻转到1。输入B的50%到输出端Y的90%的传输路径延时。</p><p class="text-idt25" data-id="353">当输入A为1时，输入B从1翻转到0时，输出Y从1翻转到0。输入B的50%到输出端Y的10%的传输路径延时。</p><p class="text-idt25" data-id="354">当输入B为1时，输入A从0翻转到1时，输出Y从0翻转到1。输入A的50%到输出端Y的90%的传输路径延时。</p><p class="text-idt25" data-id="355">当输入B为1时，输入A从1翻转到0时，输出Y从1翻转到0。输入A的50%到输出端Y的10%的传输路径延时。</p><p class="text-idt25" data-id="356">下表是10个电路相对应的传输路径延时的数量：</p><p class="text-idt25" data-id="357">表3-510个电路的传输路径延时</p><p class="text-idt25" data-id="358">INV</p><p class="text-idt25" data-id="359">AND2</p><p class="text-idt25" data-id="360">AND3</p><p class="text-idt25" data-id="361">NOR2B</p><p class="text-idt25" data-id="362">NOR2</p><p class="text-idt25" data-id="363">AOI211</p><p class="text-idt25" data-id="364">XOR3</p><p class="text-idt25" data-id="365">ADDF</p><p class="text-idt25" data-id="366">DFFNQ</p><p class="text-idt25" data-id="367">DFFNSRPQ</p><p class="text-idt25" data-id="368">2</p><p class="text-idt25" data-id="369">4</p><p class="text-idt25" data-id="370">6</p><p class="text-idt25" data-id="371">4</p><p class="text-idt25" data-id="372">4</p><p class="text-idt25" data-id="373">16</p><p class="text-idt25" data-id="374">24</p><p class="text-idt25" data-id="375">36</p><p class="text-idt25" data-id="376">3</p><p class="text-idt25" data-id="377">3</p><p class="text-idt25" data-id="378">3.3 时序预测</p><p class="text-idt25" data-id="379">本课题提出了两种方法实现预测标准电路的路径延时：电路参数方法和时序方法。</p><p class="text-idt25" data-id="380">3.3.1 电路参数方法</p><p class="text-idt25" data-id="381">作为集成电路的最小单元，金属氧化物半导体效应晶体管（MOSFET）的各种特性体现在电路的特性上。MOSFET根据载流子的极性不同，可以分为NMOSFET和PMOSFET。</p><p class="text-idt25" data-id="382">MOSFET晶体管都是有漏极（Drain）、栅极（Gate）、源级（Source）与衬底（Body）。每个终端都影响着MOSFET的电路特性，不同MOSFET的逻辑组合又具备不同的电路特性。本课题选择了一些MOSFET的电路参数作为机器学习的特性，作为用于机器学习的特征。</p><p class="text-idt25" data-id="383">表3-6电路参数表及其含义</p><p class="text-idt25" data-id="384">Ivin (A)</p><p class="text-idt25" data-id="385">信号上升或下降时VIN电压的电流的峰值</p><p class="text-idt25" data-id="386">Ivdd (A)</p><p class="text-idt25" data-id="387">信号上升或下降时VDD电压的电流的峰值</p><p class="text-idt25" data-id="388">Ivss (A)</p><p class="text-idt25" data-id="389">信号上升或下降时VSS 电压的电流的峰值</p><p class="text-idt25" data-id="390">Ion (A)</p><p class="text-idt25" data-id="391">信号上升或下降后MOS管的电流的平均数值</p><p class="text-idt25" data-id="392">Ipeak (A)</p><p class="text-idt25" data-id="393">信号上升或下降后MOS管的电流的峰值</p><p class="text-idt25" data-id="394">Vth (V)</p><p class="text-idt25" data-id="395">信号上升或下降时MOS管的阈值电压</p><p class="text-idt25" data-id="396">以INV为例，共有325组仿真数据，每组数据有9个电路参数作为拟合的特征（Feature）和一个路径延时作为目标（Target）。表中所示是五组INV的特征和目标值。</p><p class="text-idt25" data-id="397">表3-7五组INV的电路参数与延时</p><p class="text-idt25" data-id="398">Ivin1</p><p class="text-idt25" data-id="399">(10-6A)</p><p class="text-idt25" data-id="400">Ivdd</p><p class="text-idt25" data-id="401">(10-6A)</p><p class="text-idt25" data-id="402">Ivss</p><p class="text-idt25" data-id="403">(10-6A)</p><p class="text-idt25" data-id="404">Vth1</p><p class="text-idt25" data-id="405">(V)</p><p class="text-idt25" data-id="406">Vth2</p><p class="text-idt25" data-id="407">(V)</p><p class="text-idt25" data-id="408">Ion1</p><p class="text-idt25" data-id="409">(10-9A)</p><p class="text-idt25" data-id="410">Ion2</p><p class="text-idt25" data-id="411">(10-9A)</p><p class="text-idt25" data-id="412">Ipeak1</p><p class="text-idt25" data-id="413">(10-5A)</p><p class="text-idt25" data-id="414">Ipeak2</p><p class="text-idt25" data-id="415">(10-6A)</p><p class="text-idt25" data-id="416">Delay</p><p class="text-idt25" data-id="417">(10-11s)</p><p class="text-idt25" data-id="418">5.868</p><p class="text-idt25" data-id="419">4.419</p><p class="text-idt25" data-id="420">7.076</p><p class="text-idt25" data-id="421">6.802</p><p class="text-idt25" data-id="422">5.461</p><p class="text-idt25" data-id="423">1.345</p><p class="text-idt25" data-id="424">1.020</p><p class="text-idt25" data-id="425">9.112</p><p class="text-idt25" data-id="426">1.614</p><p class="text-idt25" data-id="427">1.422</p><p class="text-idt25" data-id="428">4.226</p><p class="text-idt25" data-id="429">3.226</p><p class="text-idt25" data-id="430">11.97</p><p class="text-idt25" data-id="431">5.830</p><p class="text-idt25" data-id="432">3.938</p><p class="text-idt25" data-id="433">0.5129</p><p class="text-idt25" data-id="434">0.2629</p><p class="text-idt25" data-id="435">0.2456</p><p class="text-idt25" data-id="436">0.4511</p><p class="text-idt25" data-id="437">0.5768</p><p class="text-idt25" data-id="438">0.5063</p><p class="text-idt25" data-id="439">0.3713</p><p class="text-idt25" data-id="440">0.3713</p><p class="text-idt25" data-id="441">0.5922</p><p class="text-idt25" data-id="442">0.4257</p><p class="text-idt25" data-id="443">4.357</p><p class="text-idt25" data-id="444">1.663</p><p class="text-idt25" data-id="445">5.097</p><p class="text-idt25" data-id="446">2.508</p><p class="text-idt25" data-id="447">15.85</p><p class="text-idt25" data-id="448">0.9851</p><p class="text-idt25" data-id="449">2.142</p><p class="text-idt25" data-id="450">4.475</p><p class="text-idt25" data-id="451">0.6069</p><p class="text-idt25" data-id="452">4.057</p><p class="text-idt25" data-id="453">1.650</p><p class="text-idt25" data-id="454">1.064</p><p class="text-idt25" data-id="455">2.466</p><p class="text-idt25" data-id="456">1.996</p><p class="text-idt25" data-id="457">1.358</p><p class="text-idt25" data-id="458">4.074</p><p class="text-idt25" data-id="459">3.672</p><p class="text-idt25" data-id="460">13.06</p><p class="text-idt25" data-id="461">6.239</p><p class="text-idt25" data-id="462">3.789</p><p class="text-idt25" data-id="463">3.146</p><p class="text-idt25" data-id="464">2.527</p><p class="text-idt25" data-id="465">1.859</p><p class="text-idt25" data-id="466">1.456</p><p class="text-idt25" data-id="467">4.058</p><p class="text-idt25" data-id="468">本次学习使用10折交叉验证（10-Fold Cross Validation），每次学习使用32组仿真数据作为训练集，另外的293组仿真数据作为测试集。</p><p class="text-idt25" data-id="469">本次学习选择了拟合优度作为拟合程度的度量，拟合优度（Goodness of Fit）是指回归模型对观测值的拟合程度。度量拟合优度的统计量是可决系数（determination coefficients）R2。可决系数的值越接近1，说明回归直线对观测值的拟合程度越好；反之，可决系数的值越小，说明回归直线对观测值的拟合程度越差。</p><p class="text-idt25" data-id="470">2</p><p class="text-idt25" data-id="471">=1</p><p class="text-idt25" data-id="472">可决系数的表达式如上，其中</p><p class="text-idt25" data-id="473">是回归平方，</p><p class="text-idt25" data-id="474">是总平方和。是表示因变量与所有自变量之间的总体关系。拟合优度的可决系数是无量纲系数，有确定的取值范围（0-1），便于对不同资料回归模型的拟合优度进行比较。</p><p class="text-idt25" data-id="475">表3-8十个标准电路延时训练集与测试集的拟合优度</p><p class="text-idt25" data-id="476">R2</p><p class="text-idt25" data-id="477">INV</p><p class="text-idt25" data-id="478">AND2</p><p class="text-idt25" data-id="479">AND3</p><p class="text-idt25" data-id="480">NOR2B</p><p class="text-idt25" data-id="481">NOR2</p><p class="text-idt25" data-id="482">AOI211</p><p class="text-idt25" data-id="483">XOR3</p><p class="text-idt25" data-id="484">ADDF</p><p class="text-idt25" data-id="485">DFFNQ</p><p class="text-idt25" data-id="486">DFFNSRPQ</p><p class="text-idt25" data-id="487">Train</p><p class="text-idt25" data-id="488">0.968</p><p class="text-idt25" data-id="489">0.973</p><p class="text-idt25" data-id="490">0.968</p><p class="text-idt25" data-id="491">0.982</p><p class="text-idt25" data-id="492">0.989</p><p class="text-idt25" data-id="493">0.960</p><p class="text-idt25" data-id="494">0.989</p><p class="text-idt25" data-id="495">0.995</p><p class="text-idt25" data-id="496">0.996</p><p class="text-idt25" data-id="497">0.971</p><p class="text-idt25" data-id="498">Test</p><p class="text-idt25" data-id="499">0.962</p><p class="text-idt25" data-id="500">0.930</p><p class="text-idt25" data-id="501">0.952</p><p class="text-idt25" data-id="502">0.973</p><p class="text-idt25" data-id="503">0.983</p><p class="text-idt25" data-id="504">0.924</p><p class="text-idt25" data-id="505">0.962</p><p class="text-idt25" data-id="506">0.962</p><p class="text-idt25" data-id="507">0.965</p><p class="text-idt25" data-id="508">0.940</p><p class="text-idt25" data-id="509">本次学习还选择了准确度（Accuracy）作为预测时序准确度的评价标准。准确度和相对误差一般由公式表示：</p><p class="text-idt25" data-id="510">=100%</p><p class="text-idt25" data-id="511">=1</p><p class="text-idt25" data-id="512">其中，是准确度，是实际相对误差，是绝对误差，L为真实值。相对误差一般表示为百分数。相对误差越接近0，表示预测的时序的准确度越好，预测值与真实值越接近。同样的，准确度越接近1，表示预测的时序的准确度越好，预测值与真实值越接近。</p><p class="text-idt25" data-id="513">表3-9十个标准电路延时训练集与测试集的预测准确度</p><p class="text-idt25" data-id="514">INV</p><p class="text-idt25" data-id="515">AND2</p><p class="text-idt25" data-id="516">AND3</p><p class="text-idt25" data-id="517">NOR2B</p><p class="text-idt25" data-id="518">NOR2</p><p class="text-idt25" data-id="519">AOI211</p><p class="text-idt25" data-id="520">XOR3</p><p class="text-idt25" data-id="521">ADDF</p><p class="text-idt25" data-id="522">DFFNQ</p><p class="text-idt25" data-id="523">DFFNSRPQ</p><p class="text-idt25" data-id="524">Train</p><p class="text-idt25" data-id="525">0.836</p><p class="text-idt25" data-id="526">0.941</p><p class="text-idt25" data-id="527">0.968</p><p class="text-idt25" data-id="528">0.985</p><p class="text-idt25" data-id="529">0.935</p><p class="text-idt25" data-id="530">0.887</p><p class="text-idt25" data-id="531">0.940</p><p class="text-idt25" data-id="532">0.991</p><p class="text-idt25" data-id="533">0.993</p><p class="text-idt25" data-id="534">0.982</p><p class="text-idt25" data-id="535">Test</p><p class="text-idt25" data-id="536">0.859</p><p class="text-idt25" data-id="537">0.796</p><p class="text-idt25" data-id="538">0.952</p><p class="text-idt25" data-id="539">0.958</p><p class="text-idt25" data-id="540">0.771</p><p class="text-idt25" data-id="541">0.779</p><p class="text-idt25" data-id="542">0.754</p><p class="text-idt25" data-id="543">0.954</p><p class="text-idt25" data-id="544">0.955</p><p class="text-idt25" data-id="545">0.958</p><p class="text-idt25" data-id="546">电路参数方法可以取得很好的预测效果，与此同时，所有的电路参数中，Ivdd、Ivss在电路中只有一个；Ivin的数量对应输入端的数量；Vth、Ion、Ipeak每一个MOS管都有。对于小电路，电路参数不是很多，然而，对于 DFF这种复杂一些的电路，则有三十多个 MOS管，电路参数方法会有大概一百个电路参数作为学习的特征。</p><p class="text-idt25" data-id="547">电路参数方法对于标准单元仿真周期，我们采用时间成本和机器资源成本来进行评价。</p><p class="text-idt25" data-id="548">以UMC28nmHLP为例，通常以50个核来进行仿真，大致需要24小时。采用本方法后，以50个核来进行仿真数据的采集以及时序数据预测，大致需要17小时。</p><p class="text-idt25" data-id="549">3.3.2 时序方法</p><p class="text-idt25" data-id="550">从Process corner来看，一般而言，时序都随着Process、Voltage、Temperature的变化呈现相对应的变化。</p><p class="text-idt25" data-id="551">以DFF为例，本方法以其他标准单元电路的时序作为学习的特征，DFF的时序作为目标。其中其他标准单元电路分别是INV、AND2、AND3、NOR2B、NOR2、AOI211、XOR3和ADDF。如图是5个process corner下的DFF的时序，分别是传输路径延时、setup time和hold time。</p><p class="text-idt25" data-id="552">本学习也是用10折交叉验证，表列出了DFF的时序拟合优度。表列出了DFF的准确度。可决系数的值越接近1，说明回归直线对观测值的拟合程度越好，同样的，准确度越接近1，表示预测的时序的准确度越好，预测值与真实值越接近。</p><p class="text-idt25" data-id="553">表3-10DFFs的传输路径延时、setup time和hold time在5个corner下时序</p><p class="text-idt25" data-id="554">Process corner</p><p class="text-idt25" data-id="555">DFFNQ</p><p class="text-idt25" data-id="556">DFFNSRPQ</p><p class="text-idt25" data-id="557">Path delay</p><p class="text-idt25" data-id="558">[10-11s]</p><p class="text-idt25" data-id="559">Setup time</p><p class="text-idt25" data-id="560">[10-11s]</p><p class="text-idt25" data-id="561">Hold time</p><p class="text-idt25" data-id="562">[10-11s]</p><p class="text-idt25" data-id="563">Path delay</p><p class="text-idt25" data-id="564">[10-11s]</p><p class="text-idt25" data-id="565">Setup time</p><p class="text-idt25" data-id="566">[10-11s]</p><p class="text-idt25" data-id="567">Hold time</p><p class="text-idt25" data-id="568">[10-11s]</p><p class="text-idt25" data-id="569">tt1p05v0c</p><p class="text-idt25" data-id="570">ff1p26v125c</p><p class="text-idt25" data-id="571">ss0p84vn40c</p><p class="text-idt25" data-id="572">sf1p05v25c</p><p class="text-idt25" data-id="573">fs1p05v85c</p><p class="text-idt25" data-id="574">7.766</p><p class="text-idt25" data-id="575">4.378</p><p class="text-idt25" data-id="576">72.50</p><p class="text-idt25" data-id="577">7.999</p><p class="text-idt25" data-id="578">7.915</p><p class="text-idt25" data-id="579">8.880</p><p class="text-idt25" data-id="580">4.760</p><p class="text-idt25" data-id="581">65.69</p><p class="text-idt25" data-id="582">9.969</p><p class="text-idt25" data-id="583">7.918</p><p class="text-idt25" data-id="584">5.857</p><p class="text-idt25" data-id="585">3.634</p><p class="text-idt25" data-id="586">49.26</p><p class="text-idt25" data-id="587">5.928</p><p class="text-idt25" data-id="588">6.556</p><p class="text-idt25" data-id="589">9.717</p><p class="text-idt25" data-id="590">5.059</p><p class="text-idt25" data-id="591">95.01</p><p class="text-idt25" data-id="592">9.793</p><p class="text-idt25" data-id="593">10.05</p><p class="text-idt25" data-id="594">11.92</p><p class="text-idt25" data-id="595">6.276</p><p class="text-idt25" data-id="596">92.43</p><p class="text-idt25" data-id="597">12.46</p><p class="text-idt25" data-id="598">12.24</p><p class="text-idt25" data-id="599">8.879</p><p class="text-idt25" data-id="600">5.396</p><p class="text-idt25" data-id="601">72.91</p><p class="text-idt25" data-id="602">8.312</p><p class="text-idt25" data-id="603">10.67</p><p class="text-idt25" data-id="604">表3-11DFFs的传输路径延时、setup time和hold time的拟合优度</p><p class="text-idt25" data-id="605">R2</p><p class="text-idt25" data-id="606">DFFNQ</p><p class="text-idt25" data-id="607">DFFNSRPQ</p><p class="text-idt25" data-id="608">Path delay</p><p class="text-idt25" data-id="609">Setup time</p><p class="text-idt25" data-id="610">Hold time</p><p class="text-idt25" data-id="611">Path delay</p><p class="text-idt25" data-id="612">Setup time</p><p class="text-idt25" data-id="613">Hold time</p><p class="text-idt25" data-id="614">Training set</p><p class="text-idt25" data-id="615">0.9991</p><p class="text-idt25" data-id="616">0.9996</p><p class="text-idt25" data-id="617">0.9989</p><p class="text-idt25" data-id="618">0.9990</p><p class="text-idt25" data-id="619">0.9996</p><p class="text-idt25" data-id="620">0.9990</p><p class="text-idt25" data-id="621">Testing set</p><p class="text-idt25" data-id="622">0.9984</p><p class="text-idt25" data-id="623">0.9987</p><p class="text-idt25" data-id="624">0.9980</p><p class="text-idt25" data-id="625">0.9979</p><p class="text-idt25" data-id="626">0.9992</p><p class="text-idt25" data-id="627">0.9983</p><p class="text-idt25" data-id="628">表3-12DFFs的传输路径延时、setup time和hold time的预测准确度</p><p class="text-idt25" data-id="629">DFFNQ</p><p class="text-idt25" data-id="630">DFFNSRPQ</p><p class="text-idt25" data-id="631">Path delay</p><p class="text-idt25" data-id="632">Setup time</p><p class="text-idt25" data-id="633">Hold time</p><p class="text-idt25" data-id="634">Path delay</p><p class="text-idt25" data-id="635">Setup time</p><p class="text-idt25" data-id="636">Hold time</p><p class="text-idt25" data-id="637">Training set</p><p class="text-idt25" data-id="638">0.9923</p><p class="text-idt25" data-id="639">0.9907</p><p class="text-idt25" data-id="640">0.9772</p><p class="text-idt25" data-id="641">0.9981</p><p class="text-idt25" data-id="642">0.9946</p><p class="text-idt25" data-id="643">0.9763</p><p class="text-idt25" data-id="644">Testing set</p><p class="text-idt25" data-id="645">0.9912</p><p class="text-idt25" data-id="646">0.9821</p><p class="text-idt25" data-id="647">0.9874</p><p class="text-idt25" data-id="648">0.9901</p><p class="text-idt25" data-id="649">0.9846</p><p class="text-idt25" data-id="650">0.9854</p><p class="text-idt25" data-id="651">从上表可以看出，时序方法可以取得相当好的预测效果。</p><p class="text-idt25" data-id="652">与电路参数方法相比较，时序方法所需要的特征数目较少，只需要其他电路的时序即可。不需要每个电路的每个MOS管的电路参数。</p><p class="text-idt25" data-id="653">时序方法对于标准单元仿真周期，我们采用时间成本和机器资源成本来进行评价。</p><p class="text-idt25" data-id="654">以UMC28nmHLP为例，通常以50个核来进行仿真，大致需要24小时。采用本方法后，以50个核来进行仿真数据的采集以及时序数据预测，大致需要12小时。</p><p class="text-idt25" data-id="655">3.4本章小结</p><p class="text-idt25" data-id="656">本章详细阐述了标准单元方法和标准单元库流程，着重讲述了时序库LIB文件，分析了标准单元库仿真的周期时长。并通过电路参数方法和时序方法两种方法，使用最小二乘回归算法预测了标准单元电路的时序，其中电路参数方法的预测时序的准确度能达到94.58%和87.36%；时序方法的预测时序的准确度能达到98.82%和98.68%。并从时间成本和机器资源成本对两种方法进行了评估，电路参数方法节约时间大致有30%，时序方法节约时间大致有50%。</p><p class="text-idt25" data-id="657">第四章 SRAM编译器</p><p class="text-idt25" data-id="658">本章以 TSMC28 nm SRAM为例，选择六管单元作为设计方案，介绍了 SRAM编译器，然后详细分析 SRAM编译器的表征（ Characterization），提出预测三种仿真数据的方法，最后对预测的结果和预测方法进行了评价。</p><p class="text-idt25" data-id="659">4.1 SRAM基本原理</p><p class="text-idt25" data-id="660">4.1.1 SRAM架构</p><p class="text-idt25" data-id="661">TSMC 28nm SRAM架构如图4-1。</p><p class="text-idt25" data-id="662">图4-1SRAM电路框架图</p><p class="text-idt25" data-id="663"> SRAM即静态随机存取存储器， SRAM主要由存储单元阵列（ Core Cell Array）、地址译码器（ Decoder）、灵敏放大器（ Sense Amplifier）、控制电路（ Control circuit）和缓冲/驱动电路（ FFIO）。</p><p class="text-idt25" data-id="664">如上图4-1，存储单元阵列有2 m行和2 n列，分别表示存储阵列有2 m根字线（ Word line）构成，每个字深存储2 n根位线（ Bit line）。每个SRAM包含2m2n个存储单元。每个存储单元与一根字线和一组反相的位线相连接，并通过它们进行对存储单元的读写操作。</p><p class="text-idt25" data-id="665">译码器分为行译码器（Row decoder）和列译码器（Column decoder）。行译码器接收地址信号，选中一根字线触发阵列的一行，在进行读操作的时候，字线驱动位线，反相的位线通过灵敏放大器读出存储单元的数据。</p><p class="text-idt25" data-id="666">通常为了节省功耗和减少数据读取时间，存储器中的字数会远远多于每个字存储的位数，这样会使得存储器变得长而窄，因为位线过长会增加数据访问的速度。</p><p class="text-idt25" data-id="667">4.1.2 SRAM存储单元</p><p class="text-idt25" data-id="668">图4-2SRAM 6管单元原理图</p><p class="text-idt25" data-id="669">图中所示为6管SRAM单元，存储单元使用一根字线（Word Line）、两根反相的位线（bit和bit_b）。单元中包括了一对交叉耦合的反相器，并且每根位线链接了一个存取晶体管。一对互补的数据存储在交叉耦合的反相器上。如果数据受到轻微的干扰，由回路构成的正反馈将使数据恢复到VDD或GND。选中这个单元的字线就可以对这个单元进行读出或写入。</p><p class="text-idt25" data-id="670">图4-3 TSMC 28nm 6管单元的版图</p><p class="text-idt25" data-id="671">如图4-3为TSMC 28nm SRAM Compiler的存储单元的版图。</p><p class="text-idt25" data-id="672">4.1.2SRAM Compiler</p><p class="text-idt25" data-id="673">一般而言，Memory Compiler属于IPs的一种，目前部分Design House和Foundry都可以向客户提供配套的Memory Compiler。Memory Compiler是设计一套完整的存储器单元模块（SRAM、Flash等）。设计中包含不同大小的存储器单元模块，尽量做到单元模块的面积和速度最优。用户可以通过简单的界面定义实现目标要求的存储器单元模块的GDSII文件和网表文件等。由于用户不能更改电路的内部结构和版图，所以面积和速度就是Memory Compiler的竞争力所在。</p><p class="text-idt25" data-id="674">常用SRAMs是全定制设计，全定制设计以存储器密度、速度、功耗和良率为主要设计目标，全定制设计需要相应较长的设计周期。能在较短时间内完成满足设计需求的SRAM，就意味着在高度竞争的市场中具有强有力的竞争力。SRAM Compiler就是一种解决方法，SRAM Compiler不仅能节约成本，而且能在很大程度的缩短设计周期。</p><p class="text-idt25" data-id="675">SRAM Compiler是一种能生成不同存储器配置的计算机智能化程序。SRAM Compiler主要功能包括：产生存储器网表（ netlist）、模拟最坏情况下读写路径以产生时序信息、为在原理图中取代 SRAM而建立相应的符号、建立带有时序信息的模拟模型、产生对应 SRAM的物理版图、建立电源栅结构等。通常SRAM Compiler用来为诸如门阵列或标准单元电路的专用集成电路（ASICs）生成存储器。</p><p class="text-idt25" data-id="676">4.1.2.1SRAM Compiler设计流程</p><p class="text-idt25" data-id="677">图4-4SRAM Compiler设计流程图</p><p class="text-idt25" data-id="678">SRAM Compiler通过调用设计电路结构中的子模块的版图来产生存储器模块版图，所以不同的电路设计结构得到的版图会对SRAM Compiler的面积有很大的影响。</p><p class="text-idt25" data-id="679">如图4-4是SRAM Compiler的设计流程，发开一套SRAM Compiler的主要流程如下：根据客户的需求以及市场信息，提出对 SRAM的设计需求，主要是 SRAM所具备的一些功能和特征，并对存储器单元进行评估，并检查是否满足存储器设计的速度和面积要求；然后对SPEC的配置进行电路图设计及预仿真，其次是页元（Leaf cell）的版图设计，通过DRC和LVS规则对电路图和版图进行优化调整；使用 SRAM Compiler的 Tiling Engine来产生存储器模板（ Memory Instance）版图，最后是对不同配置的 Instance进行表征（ Characterization），主要通过时序（ Timing）、功耗（ Power）和电容（ Capacitance）来体现。</p><p class="text-idt25" data-id="680">在Memory Characterization环节中，主要是仿真工作和仿真数据收集。实际设计中，仿真工作的时间几乎占据了全部的Memory Characterization环节。因为仿真工作的数量由SPEC配置和PVT共同决定。而SPEC与PVT参数包含了特征、MUX、Bank、Word、Bit、Input Slew、Output loading、Process Corner、Voltage以及Temperature等。参数的繁多决定了仿真工作的数量的繁多。</p><p class="text-idt25" data-id="681">4.1.2.2SRAM Compiler整合流程</p><p class="text-idt25" data-id="682">图4-5 SRAM Compiler整合流程图</p><p class="text-idt25" data-id="683"> Leaf cell的版图和电路在通过 DRC和 LVS之后，通过 Tiling Engine的脚本生成不同 instance以及 instance的版图文件（ LEF、 GDSII文件）和电路描述文件（ Verilog语言文件、 SPICE文件）；</p><p class="text-idt25" data-id="684"> Characterization环节通过设计者给出的 Instance列表对 instance抽象成 CP（ Critical Path），通过 Word、 Bit， Feature的变化来改变 CP中的各个参数，模拟对应 Instance的行为，节省了仿真时间，同时还不是准确性。针对不同instance的SPEC配置文件的变量参数进行配置，通过脚本自动生成仿真文件，并进行仿真；</p><p class="text-idt25" data-id="685">仿真完成后，通过测量描述语言对仿真结果文件进行数据抽取，生成Rawdata文件，并通过计算文件生成最后的LIB文件。</p><p class="text-idt25" data-id="686">最后将 LIB文件、 LEF文件、 GDSII文件、 Verilog文件和 SPICE文件整合，编写 Complier实现程序，使得用户可以通过自定义 instance的大小与功能自动生成 SRAM及其网表文件、版图文件与表征数据库等。</p><p class="text-idt25" data-id="687">通过 Compiler工具中的各种引擎模块调用设计中相应的设计输入文件，如 SPEC配置文件、 Compiler的物理单元库（ GDS），网表单元库（ Netlist）、 Memory Development Language（ MDL）语言脚本等文件，具体需要的文件见图；Memory Compiler的输出文件结构如图，大致有GDSII、LEF、SPICE和Verilog文件等。</p><p class="text-idt25" data-id="688">图4-6Memory Compiler输入输出文件结构</p><p class="text-idt25" data-id="689">4.2 Memory Characterization</p><p class="text-idt25" data-id="690">4.2.1仿真工作</p><p class="text-idt25" data-id="691">Memory Characterization是SRAM Compiler设计中非常重要的环节，主要是instance的仿真工作以及仿真数据的收集。其中仿真数据主要是时序和功耗。</p><p class="text-idt25" data-id="692">Characterization的仿真工作具有一定的重复性，可以通过脚本的实现来生成Test bench，进行仿真、数据检查以及数据收集。Characterization减少了设计者的仿真时间，同时也可以减少一些人为的错误。</p><p class="text-idt25" data-id="693">仿真的工作量主要由SPEC配置和PVT共同决定，SPEC配置有FEATURE、MUX、BANK、WORD、BIT、INPUT SLEW和OUTPUT LOADING等。</p><p class="text-idt25" data-id="694">4.2.2 特征</p><p class="text-idt25" data-id="695">本课题SRAM Compiler所采用的工艺是TSMC28nm的HPC+工艺版本，本课题SRAM Compiler所采用的功能如下：</p><p class="text-idt25" data-id="696">Synchronous read and write operations</p><p class="text-idt25" data-id="697">Column Mux options for the best aspect ratio</p><p class="text-idt25" data-id="698">Fully customized layout density available in 0.9V 10%</p><p class="text-idt25" data-id="699">Three power management modes: Light Sleep， Deep Sleep and Shut Down to reduce static power</p><p class="text-idt25" data-id="700">Bit write and global write operations available</p><p class="text-idt25" data-id="701">Extra margin control option</p><p class="text-idt25" data-id="702">Special test modes externally bypass read and write self-timing circuits</p><p class="text-idt25" data-id="703">Redundancy inside to repair defective cell</p><p class="text-idt25" data-id="704">表4-1TSMC28nm SRAM Compiler具备的特征</p><p class="text-idt25" data-id="705">1</p><p class="text-idt25" data-id="706">具有deep sleep模式</p><p class="text-idt25" data-id="707">2</p><p class="text-idt25" data-id="708">具有shut down模式</p><p class="text-idt25" data-id="709">P</p><p class="text-idt25" data-id="710">具有light sleep功能</p><p class="text-idt25" data-id="711">B</p><p class="text-idt25" data-id="712">具有Bit write功能</p><p class="text-idt25" data-id="713">I</p><p class="text-idt25" data-id="714">具有IO redundancy功能</p><p class="text-idt25" data-id="715">M</p><p class="text-idt25" data-id="716">具有BIST功能</p><p class="text-idt25" data-id="717">E</p><p class="text-idt25" data-id="718">具有HVT Periphery功能</p><p class="text-idt25" data-id="719">L</p><p class="text-idt25" data-id="720">具有LVT Periphery功能</p><p class="text-idt25" data-id="721">用户可以通过定义不同的word、bit和mux来优化存储器，从而实现面积、速度和功耗的最佳平衡。以上的特征都被集成到Memory Compiler中，用来实现系统应用和用户需求。在设定一些参数之后，Compiler就可以在很短的时间内生成memory instance的data sheet、GDSII Layout、LVS netlist和PR model等。</p><p class="text-idt25" data-id="722">通常，Memory Compiler所提供的全部功能，用户在自定义生成SRAM的时候，根据需求选择其中几个或者全部的功能。这就要求在进行仿真的时候，针对不同的特征组合进行不同的仿真，这也是仿真工作量繁多的重要原因。</p><p class="text-idt25" data-id="723">以下为需要进行仿真的特征组合：</p><p class="text-idt25" data-id="724">-</p><p class="text-idt25" data-id="725">1，2，b，i，m，p</p><p class="text-idt25" data-id="726">12，1b，1i，1m，1p，2b，2i，2m，2p，bi，bm，bp，im，ip，mp</p><p class="text-idt25" data-id="727">12b，12i，12m，12p，1bi，1bm，1bp，1im，1ip，1mp，</p><p class="text-idt25" data-id="728">2bi，2bm，2bp，2im，2ip，2mp，bim，bip，bmp，imp</p><p class="text-idt25" data-id="729">12bi，12bm，12bp，12im，12ip，12mp，1bim，1bip，</p><p class="text-idt25" data-id="730">1bmp，1imp，2bim，2bip，2bmp，2imp，bimp</p><p class="text-idt25" data-id="731">12bim，12bip，12bmp，12imp，1bimp，2bimp</p><p class="text-idt25" data-id="732">12bimp</p><p class="text-idt25" data-id="733">共计64组特征。针对每一组特征都有相应的仿真工作需要完成。</p><p class="text-idt25" data-id="734">4.2.3 INSTANCE</p><p class="text-idt25" data-id="735">用户可以通过定义不同的word、bit、mux和bank来定义需求的存储器。</p><p class="text-idt25" data-id="736">通常随着存储阵列容量的变大，那么字线和位线就会变得更长。增加字线和位线的长度会使电容变大，从而导致延时和功耗的增加。因此，通常会将大容量的存储阵列分割成为多个较小的存储阵列，这样的较小的存储阵列就被称为体（Bank）。</p><p class="text-idt25" data-id="737">通常为了节省功耗和减少数据读取时间，存储阵列中的字数会远远多于每个字存储的位数，这样会使得存储器变得长而窄，因为位线过长会增加数据访问的速度。</p><p class="text-idt25" data-id="738">图4-7Mux示意图</p><p class="text-idt25" data-id="739">通常采用的另一个做法就是减少位线的长度。如图将一根正常的位线分割成两部分，每根位线的长度与其所驱动的单元数都减半，从而减少了位线的负载。这样子分割位线的做法叫做Column Mux。其中每根位线的长度被分成几份，Mux就等于几，且Mux总是2的幂值。在具体的SRAM Compiler设计中，会提供很多不同的字线、位线和Mux来供用户进行选择。</p><p class="text-idt25" data-id="740">本课题的SRAM Compiler是小面积的存储器，设计中不分Bank，因此Bank的值为1。</p><p class="text-idt25" data-id="741">Mux根据SPEC文件定义为2和4。当Mux取2时，Word最小取32，最大取512，步长为4，Bit最小取8，最大取144，步长为2；当Mux取4时，Word最小取64，最大取1024，步长为8，Bit最小取8，最大取72，步长为1。</p><p class="text-idt25" data-id="742">表4-2字长根据Mux不同的选择范围</p><p class="text-idt25" data-id="743">Word Range</p><p class="text-idt25" data-id="744">Column Mux=2</p><p class="text-idt25" data-id="745">32，36，40，508，512</p><p class="text-idt25" data-id="746">Column Mux=4</p><p class="text-idt25" data-id="747">64，72，80，1016，1024</p><p class="text-idt25" data-id="748">表4-3位线根据Mux不同的选择范围</p><p class="text-idt25" data-id="749">Bit Range</p><p class="text-idt25" data-id="750">Column Mux=2</p><p class="text-idt25" data-id="751">8，10，12，142，144</p><p class="text-idt25" data-id="752">Column Mux=4</p><p class="text-idt25" data-id="753">8，9，10，71，72</p><p class="text-idt25" data-id="754">当Mux选定2或者4的时候，选择不同的Word和Bit的值即可确定Memory Instance的大小。从上表可以看出，当Mux=2的时候，Word可取120个值，Bit可以取140个值；当Mux=4的时候，Word可以取120个值，Bit可以取64个值。由此可计算出本课题的SRAM Compiler的Instance个数共有24480个。理论上，用户自定义生成的Memory Instance的可以是24480中的任何一种，这就要求每一个Memory Instance都有相应的仿真数据，供用户查询。仿真阶段完成所有的Instance的仿真是不可能实现的，通常设计公司会提供比较典型的几个Instance的仿真数据。而客户需求所提供的Instance之外的仿真数据的时候，就需要设计公司重新进行仿真。</p><p class="text-idt25" data-id="755">4.2.4 IO</p><p class="text-idt25" data-id="756">在IO部分中，电路的端口主要有A、CK和DO。输入端口和时钟端口的slew的不同对电路的表征有不同的影响，在输出端口的负载的大小对电路的表征也有不同的影响。</p><p class="text-idt25" data-id="757">在SPEC文件中，input slew和output loading都设置七个值。其中 A作为数据输入的端口，采用 input slew的值，称之为 Data slew， CK作为时钟，也采用 input slew的值，称之为 CK slew， DO作为输出端，选有 output loading的值，称之为 load。</p><p class="text-idt25" data-id="758">本课题中，input slew和output loading的值如下表：</p><p class="text-idt25" data-id="759">表4-4：input slew和output loading数值表</p><p class="text-idt25" data-id="760">Input slew</p><p class="text-idt25" data-id="761">Data slew</p><p class="text-idt25" data-id="762">0.004，0.050，0.100，0.200，0.500，0.750，1.000</p><p class="text-idt25" data-id="763">CK slew</p><p class="text-idt25" data-id="764">0.004，0.050，0.100，0.200，0.500，0.750，1.000</p><p class="text-idt25" data-id="765">Output loading</p><p class="text-idt25" data-id="766">Load</p><p class="text-idt25" data-id="767">0.001，0.020，0.050，0.100，0.250，0.300，0.350</p><p class="text-idt25" data-id="768">对于instance而言，Data slew、CK slew和Load选择不同的数值的时候，都有不同的电路表征。也就是说对于某个确定的Instance而言，在IO中就有343种状态。</p><p class="text-idt25" data-id="769">4.2.5 PVT Corners</p><p class="text-idt25" data-id="770">从晶片中提取相对应的器件模型时，片上 NMOS和 PMOS的测试结构显示出不同的门延时，而这些角的实际选取是为了得到可接受的成品率。各种工艺角和极限温度条件下对电路进行仿真是决定成品率的基础。</p><p class="text-idt25" data-id="771">在不同批次和不同的晶圆之间，MOSFETs的性能变化很大。为了在一定程度上减轻电路设计任务的困难，工艺工程师们要保证器件的性能在某个范围内，大体上，他们以报废超出这个性能范围的芯片的措施来严格控制预期的参数变化。</p><p class="text-idt25" data-id="772">通常提供给设计师的性能范围只适用于数字电路并以工艺角（Process Corner）的形式给出。</p><p class="text-idt25" data-id="773">图4-8PVT Corner的示意图</p><p class="text-idt25" data-id="774">如图，其思想是：把NMOS和PMOS晶体管的速度波动范围限制在由四个角所确定的矩形内。这四个角分别是：快速NMOSFET和快速PMOSFET，慢速NMOSFET和慢速PMOSFET，快速NMOSFET和慢速PMOSFET，慢速NMOSFET和快速PMOSFET。例如具有较薄的栅氧、较低阈值电压的晶体管，就落在快速角的附近。</p><p class="text-idt25" data-id="775">从载流子迁移率（Carrier mobility）的角度而言，载流子迁移率是指在载流子在单位电场作用下的平均漂移速度。工艺角的命名方式是两个字母组合，前一个字母表示NMOS的工艺角，后一个字母表示PMOS的工艺角。工艺角的类型通常有：快速（Fast）、慢速（Slow）和正常（Typical）。以TT为例，就是指正常速度的NMOS管和正常速度的PMOS管。</p><p class="text-idt25" data-id="776">单一器件载流子迁移率的结果是呈正态分布的，均值在TT，最小最大限制值为SS与FF。从NMOS和PMOS管的迁移率分布图而言，这3种工艺角覆盖大约3 sigma即约99.73% 的范围。对于工艺偏差的情况有很多，比如掺杂浓度，制造时的温度控制，刻蚀程度等，所以造成同一个晶圆上不同区域的情况不同，以及不同晶圆之间不同情况的发生。这种随机性的发生，只有通过统计学的方法才能评估覆盖范围的合理性。</p><p class="text-idt25" data-id="777">本课题采用3 Corner model，他们是TNTP，SNSP和FNFP。</p><p class="text-idt25" data-id="778">设计除了要满足上述的Process Corner外，还需要满足电压与温度等条件， 形成的组合称为PVT (process， voltage， temperature)。</p><p class="text-idt25" data-id="779">表4-5：PVT配置表</p><p class="text-idt25" data-id="780">Process</p><p class="text-idt25" data-id="781">TT、SS、FF</p><p class="text-idt25" data-id="782">Voltage/V</p><p class="text-idt25" data-id="783">0.72、0.81、0.9、0.99、1.08</p><p class="text-idt25" data-id="784">Temperature/</p><p class="text-idt25" data-id="785">-40、25、125</p><p class="text-idt25" data-id="786">如表，电压设定数值分别是中位电压的80%、90%、100%、110%和120%。设计时还需要找到最好最坏情况，时序分析中将最好的条件(Best Case)定义为速度最快的情况， 而最坏的条件(Worst Case)则相反。</p><p class="text-idt25" data-id="787">根据不同的需要，会有不同的PVT组合，以下是一些标准的分析条件：</p><p class="text-idt25" data-id="788">WCS（Worst Case Slow）：slow process、high temperature、lowest voltage</p><p class="text-idt25" data-id="789">TYP（Typical）：typical process、nominal temperature、nominal voltage</p><p class="text-idt25" data-id="790">WCL（Worst Case Cold）：slow process、lowest temperature、lowest voltage</p><p class="text-idt25" data-id="791">BCF（Best Case Fast）：fast process、lowest temperature、high voltage</p><p class="text-idt25" data-id="792">ML（Maximal Leakage）：fast process、high temperature、high voltage</p><p class="text-idt25" data-id="793">TL（Typical Leakage）：typical process、high temperature、nominal voltage</p><p class="text-idt25" data-id="794">前四个的PVT组合主要用于时序分析，后两者PVT组合通常用于功耗分析。与前面说设计师通常只会提供一部分Instance的仿真数据一样，设计师通常也只会提供小部分PVT的仿真数据。当用户需求超出了最初的设计范围时，需要重新进行仿真工作。</p><p class="text-idt25" data-id="795">4.3 本章小结</p><p class="text-idt25" data-id="796">本章主要介绍了SRAM的基本框架和基本电路结构，然后描述了SRAM Compiler的设计流程与主要文件类型；着重对Compiler的表征环节进行了阐述，主要分析了Instance生成所受的因素影响。并详细对特征、word、bit、mux、bank、input slew、output loading和PVT corners进行详细解释，间接地表达了memory instance数量与仿真工作量的繁多。</p><p class="text-idt25" data-id="797">第五章表征数据预测</p><p class="text-idt25" data-id="798">5.1时序</p><p class="text-idt25" data-id="799">5.1.1 时序数据</p><p class="text-idt25" data-id="800">5.1.1.1 读操作时序</p><p class="text-idt25" data-id="801">SRAM有三种工作状态：保持（Standby）、写入（Write）和读出（Read）。</p><p class="text-idt25" data-id="802">SRAM的数据保持时，芯片使能信号CEB处于无效状态，无论其他信号是什么状态，都不会对存储单元进行任何操作。</p><p class="text-idt25" data-id="803">图5-1：读操作波形示意图</p><p class="text-idt25" data-id="804">SRAM读操作时序如图，其中WEB为写使能，CK是时钟信号，CEB为片选中信号，A为地址信号，DO为数据输出信号。</p><p class="text-idt25" data-id="805">表5-1读操作时序</p><p class="text-idt25" data-id="806">Parameter</p><p class="text-idt25" data-id="807">Symbol</p><p class="text-idt25" data-id="808">Read cycle time</p><p class="text-idt25" data-id="809">Trc</p><p class="text-idt25" data-id="810">Data access time at the CK rising edge</p><p class="text-idt25" data-id="811">Tcq</p><p class="text-idt25" data-id="812">Output data hold time after the CK rising edge</p><p class="text-idt25" data-id="813">Toh</p><p class="text-idt25" data-id="814">Address setup time before the CK rising edge</p><p class="text-idt25" data-id="815">Tas</p><p class="text-idt25" data-id="816">Address hold time after the CK rising edge</p><p class="text-idt25" data-id="817">Tah</p><p class="text-idt25" data-id="818">GWEB，WEB setup time after the CK rising edge</p><p class="text-idt25" data-id="819">Tws</p><p class="text-idt25" data-id="820">GWEB，WEB hold time after the CK rising edge</p><p class="text-idt25" data-id="821">Twh</p><p class="text-idt25" data-id="822">CEB setup time before the CK rising edge</p><p class="text-idt25" data-id="823">Tces</p><p class="text-idt25" data-id="824">CEB setup time after the CK rising edge</p><p class="text-idt25" data-id="825">Tceh</p><p class="text-idt25" data-id="826">Clock high/low pulse widths</p><p class="text-idt25" data-id="827">Thpw/Tlpw</p><p class="text-idt25" data-id="828"> SRAM读取数据的时候，芯片使能信号 CEB处于低电平（有效状态），写使能信号处于高电平（无效状态），地址信号 A在时钟信号 CK的上升沿到来的前后都保持一段时间，输出信号 DO在延时之后会得到相应的数据读出。其中在时钟信号上升沿到来的前后都需保持一段时间的信号分别有地址信号A、写操作使能信号和芯片使能信号CEB。这三个信号在时钟信号上升沿到来之前保持的时间就是建立时间（Setup time），比如：Tas、Tws和Tces。相应的在时钟信号上升沿到来之后信号保持的时间就是保持时间（Hold time），比如Tah、Twh和Tceh。除此之外时钟信号CK处于高电平的时间为Thpw，处于低电平的时间为Tlpw，时钟信号的周期为Trc。输出信号DO从时钟信号上升沿到输出信号开始翻转的时间为Toh，而从时钟信号上升沿到输出信号翻转结束的时间为Tcq。其中Tcq越小说明SRAM工作越快。</p><p class="text-idt25" data-id="829">对于SRAM的延时Tcq，它主要分布在三个方面：首先是译码延时，其次是存储阵列上的延时，另外还有时钟电路、放大电路、输出驱动等延时。</p><p class="text-idt25" data-id="830">Tcq=Tcq</p><p class="text-idt25" data-id="831">cksr</p><p class="text-idt25" data-id="832">+Tcq</p><p class="text-idt25" data-id="833">instance</p><p class="text-idt25" data-id="834">+Tcq(load)</p><p class="text-idt25" data-id="835">由公式可以看出，Tcq主要有三部分组成：CKsr的延时、阵列的延时和读出路径的延时，其中cksr是Clock slew rate，load是output loading。</p><p class="text-idt25" data-id="836">图5-2Tcq组合示意图</p><p class="text-idt25" data-id="837">其中tcq(cksr)只取最大instance和最小loading时的值；tcq(inst)只取最小cksr和最小loading时的值，tcq（load）取最小cksr和最大inst的值。</p><p class="text-idt25" data-id="838">因为CK Slew和output loading都有7个数值，所以每一个instance的每一个时序都有77的查询表。</p><p class="text-idt25" data-id="839">5.1.1.2 写操作时序</p><p class="text-idt25" data-id="840">图5-3写操作波形示意图</p><p class="text-idt25" data-id="841">表5-2写操作时序表</p><p class="text-idt25" data-id="842">Parameter</p><p class="text-idt25" data-id="843">Symbol</p><p class="text-idt25" data-id="844">Write cycle time</p><p class="text-idt25" data-id="845">Twc</p><p class="text-idt25" data-id="846">Address setup time before the CK rising edge</p><p class="text-idt25" data-id="847">Tas</p><p class="text-idt25" data-id="848">Address hold time after the CK rising edge</p><p class="text-idt25" data-id="849">Tah</p><p class="text-idt25" data-id="850">GWEB，WEB setup time after the CK rising edge</p><p class="text-idt25" data-id="851">Tws</p><p class="text-idt25" data-id="852">GWEB，WEB hold time after the CK rising edge</p><p class="text-idt25" data-id="853">Twh</p><p class="text-idt25" data-id="854">Input data setup time before the CK rising edge</p><p class="text-idt25" data-id="855">Tds</p><p class="text-idt25" data-id="856">Input data hold time after the CK rising edge</p><p class="text-idt25" data-id="857">Tdh</p><p class="text-idt25" data-id="858">CEB setup time before the CK rising edge</p><p class="text-idt25" data-id="859">Tces</p><p class="text-idt25" data-id="860">CEB setup time after the CK rising edge</p><p class="text-idt25" data-id="861">Tceh</p><p class="text-idt25" data-id="862">Output data invalid after the CK rising edge</p><p class="text-idt25" data-id="863">Twdx</p><p class="text-idt25" data-id="864">Output data valid after the CK rising edge</p><p class="text-idt25" data-id="865">Twdv</p><p class="text-idt25" data-id="866">Clock high/low pulse widths</p><p class="text-idt25" data-id="867">Thpw/Tlpw</p><p class="text-idt25" data-id="868"> SRAM写操作时序如图，其中 WEB为写使能， CK是时钟信号， CEB为片选中信号， A为地址信号， DI为数据输入信号， DO为数据输出信号。</p><p class="text-idt25" data-id="869"> SRAM写数据的时候，芯片使能信号 CEB处于低电平（有效状态），写使能信号处于低电平（有效状态），地址信号 A在时钟信号 CK的上升沿到来的前后都保持一段时间，输出信号 DO在延时之后会得到相应的数据读出。其中在时钟信号上升沿到来的前后都需保持一段时间的信号分别有地址信号A、写操作使能信号、数据输入信号DI和芯片使能信号CEB。这四个信号在时钟信号上升沿到来之前保持的时间就是建立时间（Setup time），比如：Tas、Tws、Tds和Tces。相应的在时钟信号上升沿到来之后信号保持的时间就是保持时间（Hold time），比如Tah、Twh、Tdh和Tceh。除此之外时钟信号CK处于高电平的时间为Thpw，处于低电平的时间为Tlpw，时钟信号的周期为Twc。输出信号DO从时钟信号上升沿到输出信号开始翻转的时间为Twdx，而从时钟信号上升沿到输出信号翻转结束的时间为Twdv。</p><p class="text-idt25" data-id="870">5.1.1.3 电源模式时序</p><p class="text-idt25" data-id="871">图5-4Light sleep模式下电路各端口的波形示意图</p><p class="text-idt25" data-id="872">图5-5Deep sleep模式下电路各端口的波形示意图</p><p class="text-idt25" data-id="873">图5-6Shut down模式下电路各端口的波形示意图</p><p class="text-idt25" data-id="874">Parameter</p><p class="text-idt25" data-id="875">Symbol</p><p class="text-idt25" data-id="876">LS fall setup time before CK rises</p><p class="text-idt25" data-id="877">Tflss</p><p class="text-idt25" data-id="878">LS rise setup time before CK rises</p><p class="text-idt25" data-id="879">Trlsh</p><p class="text-idt25" data-id="880">DS fall setup time before CK rises</p><p class="text-idt25" data-id="881">Tfdss</p><p class="text-idt25" data-id="882">DS rise setup time before CK rises</p><p class="text-idt25" data-id="883">Trdsh</p><p class="text-idt25" data-id="884">DS rise to output hold previous data time</p><p class="text-idt25" data-id="885">Tdsoh</p><p class="text-idt25" data-id="886">DS rise to all output fall to logic 0 delay</p><p class="text-idt25" data-id="887">Tdsq</p><p class="text-idt25" data-id="888">SD fall setup time before CK rises</p><p class="text-idt25" data-id="889">Tfsds</p><p class="text-idt25" data-id="890">SD rise setup time before CK rises</p><p class="text-idt25" data-id="891">Trsdh</p><p class="text-idt25" data-id="892">SD rise to output hold previous data times</p><p class="text-idt25" data-id="893">Tsdoh</p><p class="text-idt25" data-id="894">SD rise to all output fall to logic 0 delay</p><p class="text-idt25" data-id="895">Tsdq</p><p class="text-idt25" data-id="896">表5-3电源模式时序表</p><p class="text-idt25" data-id="897">在Light sleep模式，SRAM可以在不到一个完整的时钟周期之内恢复（wake up），但其静态功耗也是三种模式中最大的；Shut down模式具有最少的静态功耗，但其恢复时间是三种模式中最长的；Deep sleep模式的静态功耗和恢复时间都是介于两者之间。</p><p class="text-idt25" data-id="898">以 W32 B8 M2 B1为例，当 ck slew=0.004， load=0.001， data slew=0.004时， Tcq在45个 corners下的值。</p><p class="text-idt25" data-id="899">图5-7全corners组合下Tcq的时序柱状图</p><p class="text-idt25" data-id="900">本课题分别从读操作时序、写操作时序和电源模式中选择20个时序，分别是 Tcq、 Toh、 Troslp、 Tfoslp、 Tsdq、 Tsdoh、 Tdsq、 Tdsoh、 Tas、 Tah、 Tds、 Tdh、 Tceh、 Tces、 Tws、 Twh、 Thpw、 Tlpw、 Trc、 Twc。</p><p class="text-idt25" data-id="901">5.1.2 时序预测</p><p class="text-idt25" data-id="902">5.1.2.1 相同Instance预测</p><p class="text-idt25" data-id="903">本方法可以实现通过某一确定Instance的CK Slew、DATA Slew和LOAD的时序预测其他所有的CKSR、DATASR和LOAD组合的时序。</p><p class="text-idt25" data-id="904">本方法使用 CK slew=0.004， Data slew=0.004， Load=0.001（组合1）的时序，去预测了其他不同 CK slew、 Data slew和 Load组合的时序。目标组合一共有7组，分别是：</p><p class="text-idt25" data-id="905">组合2：CK slew=0.004，load=0.001，data slew=0.500；</p><p class="text-idt25" data-id="906">组合3：CK slew=0.004，load=0.500，data slew=0.004；</p><p class="text-idt25" data-id="907">组合4：CK slew=0.004，load=0.500，data slew=0.500；</p><p class="text-idt25" data-id="908">组合5：CK slew=0.500，load=0.001，data slew=0.004；</p><p class="text-idt25" data-id="909">组合6：CK slew=0.500，load=0.001，data slew=0.500；</p><p class="text-idt25" data-id="910">组合7：CK slew=0.500，load=0.500，data slew=0.004；</p><p class="text-idt25" data-id="911">组合8：CK slew=0.500，load=0.500，data slew=0.500。</p><p class="text-idt25" data-id="912">本次预测采用8组corners作为训练集： FG1 P08 VN40 C、 FG0 P9 V25 C、 FG1 P08 V25 C、 TT0 P9 VN40 C、 TT0 P9 V125 C、 SG0 P81 VN40 C、 SG0 P99 VN40 C和 SG0 P9 V125 C。其他的37组Corners作为测试集。</p><p class="text-idt25" data-id="913">以 CK slew=0.500， load=0.500， data slew=0.500为目标组合，其测试集的预测时序与仿真真实时序的对比图如图。</p><p class="text-idt25" data-id="914">图5-8CK slew=0.500，load=0.500，data slew=0.500时的</p><p class="text-idt25" data-id="915">测试集corners的Tcq的仿真真实值与预测值及其预测准确度</p><p class="text-idt25" data-id="916">从图中可以看出37组Corners下Tcq的仿真值和预测值相差很小，可以从预测的准确度来观察仿真值和预测值的差异。</p><p class="text-idt25" data-id="917">例中对测试集的37组数据的准确度求平均，得到本组Tcq预测的平均准确度为99.83%。</p><p class="text-idt25" data-id="918">图5-9测试集corners的全时序仿真数据的预测平均准确度</p><p class="text-idt25" data-id="919">上图为目标组合的测试集所有时序的平均准确度。可以从图中观察到七个目标组合的测试集在37组 PVT Corners下的时序的平均准确度都处于97%以上，其中组合3和组合5的 Tds的预测准确度约为97%，除此之外所有的平均准确度都达到98%以上，而且大部分的时序的预测平均准确度可以达到99%。由此可以得出结论：本方法在 TSMC28 nm工艺下的同一 Instance，通过某一确定的 Input slew和 output loading的时序仿真数据，实现其他 Input slew和 output loading组合的时序仿真数据的预测，可以预测得到准确度很高的时序仿真数据，同时可以很有成效的减少仿真工作量，节省仿真时间和仿真资源。</p><p class="text-idt25" data-id="920">5.1.2.2 不同Instance预测</p><p class="text-idt25" data-id="921">本课题中采选用了4个 instance，他们分别是 W32 B8 M2 B1、 W32 B144 M2 B1、 W512 B8 M2 B1和 W512 B144 M2 B1。Instance的形状与阵列的大小密切相关，从版图中我们可以看出存储阵列几乎占据了SRAM版图98%的面积。4.1中讲到通常阵列会被设计成行数较少、列数较多的结构，因为位线的负载是通过并联的，过长的位线会使得 SRAM读写的速度变得很慢。相同的存储容量的SRAM会因为其字线和位线的不同具有不同的读写速度，也就是时序。</p><p class="text-idt25" data-id="922">Instance的形状与字数和位数线性相关，从版图上看Instance总是矩形，其宽通常为Word/Mux，其长通常为Bit/Mux。</p><p class="text-idt25" data-id="923">表5-44个Instance的特征、存储容量</p><p class="text-idt25" data-id="924">Inst</p><p class="text-idt25" data-id="925">W32B8M2B1</p><p class="text-idt25" data-id="926">W32B144M2B1</p><p class="text-idt25" data-id="927">W512B8M2B1</p><p class="text-idt25" data-id="928">W512B144M2B1</p><p class="text-idt25" data-id="929">WordBit</p><p class="text-idt25" data-id="930">1616</p><p class="text-idt25" data-id="931">16288</p><p class="text-idt25" data-id="932">25616</p><p class="text-idt25" data-id="933">256288</p><p class="text-idt25" data-id="934">特征</p><p class="text-idt25" data-id="935">面积最小</p><p class="text-idt25" data-id="936">矮扁</p><p class="text-idt25" data-id="937">高瘦</p><p class="text-idt25" data-id="938">面积最大</p><p class="text-idt25" data-id="939">存储容量</p><p class="text-idt25" data-id="940">0.4MB</p><p class="text-idt25" data-id="941">4.5MB</p><p class="text-idt25" data-id="942">4MB</p><p class="text-idt25" data-id="943">72MB</p><p class="text-idt25" data-id="944">本时序预测方法通过某个Instance的全corner来预测另一个instance的时序。可以实现相同CK slew、Data slew、Load的时候，通过单个instance的全corner时序以及目标instance的6、8组corners的时序，可以实现预测其他corners的时序。</p><p class="text-idt25" data-id="945">方法一：</p><p class="text-idt25" data-id="946">通过 W32 B8 M2 B1和 W32 B144 M2 B1的8组 corners时序数据作为训练集，其中 W32 B8 M2 B1的8组 corners时序数据作为训练集的特征（ Feature），而 W32 B144 M2 B1的8个 corners时序数据作为训练集的目标（ Target）。 W32 B8 M2 B1和 W32 B144 M2 B1的剩余37组时序数据作为测试集，其中 W32 B8 M2 B1的37组时序数据作为测试集的特征， W32 B144 M2 B1的37组时序数据作为测试集的目标。使用最小二乘法对训练集特征和目标进行拟合，然后测试集的特征作为输入，得到测试集的目标预测值，并与测试集的目标真实值进行对比。</p><p class="text-idt25" data-id="947">图5-10W32B144M2B1的测试集目标Tcq的仿真值、预测值以及预测准确度</p><p class="text-idt25" data-id="948">本方法中的训练集的8组 Corners分别是 FG1 P08 VN40 C、 FG0 P9 V25 C、 FG1 P08 V25 C、 TT0 P81 V25 C、 TT0 P99 V25 C、 SG0 P72 VN40 C、 SG0 P9 V25 C和 SG1 P08 V125 C。</p><p class="text-idt25" data-id="949">如图是本次预测的W32B144M2B1的测试集的Tcq的仿真值、预测值以及预测准确度。对39组Tcq的预测准确度进行求平均值，得到本次学习的平均预测准确度为99.69%。从表中也可以看出所有Tcq的预测准确度均处于99%以上，预测效果很好。</p><p class="text-idt25" data-id="950">图5-11三个目标Instances测试集的全时序预测平均准确度</p><p class="text-idt25" data-id="951">上图为 W32 B144 M2 B1、 W512 B8 M2 B1和 W512 B144 M2 B1的测试集的所有时序的平均准确度折线图。从折线图中可以观察到三组 Instance的测试集在37组 PVT Corners下的时序的平均准确度都处于97%以上，其中 W32 B144 M2 B1和 W512 B144 M2 B1的 Tas的预测平均准确度约为97%， W512 B8 M2 B1的 Tds的预测平均准确度约为97%，除此之外所有的平均准确度都达到98.5%以上，而且大部分的时序的预测平均准确度可以达到99%。</p><p class="text-idt25" data-id="952">方法二：</p><p class="text-idt25" data-id="953">本方法通过选择 W32 B8 M2 B1和 W32 B144 M2 B1的6组 corners时序数据作为训练集，其中 W32 B8 M2 B1的6组 corners时序数据作为训练集的特征，而 W32 B144 M2 B1的6个 corners时序数据作为训练集的目标。 W32 B8 M2 B1和 W32 B144 M2 B1的剩余39组时序数据作为测试集，其中 W32 B8 M2 B1的39组时序数据作为测试集的特征， W32 B144 M2 B1的39组时序数据作为测试集的目标。使用最小二乘法对训练集特征和目标进行拟合，然后测试集的特征作为输入，得到测试集的目标预测值，并与测试集的目标真实值进行对比。</p><p class="text-idt25" data-id="954">本方法中的训练集的6组 Corners分别是 FG1 P08 VN40 C、 FG1 P08 V25 C、 TT0 P81 V25 C、 TT0 P99 V25 C、 SG0 P72 VN40 C和 SG0 P72 VN40 C。</p><p class="text-idt25" data-id="955">图5-12W32B144M2B1的测试集目标Tcq的仿真值、预测值以及预测准确度</p><p class="text-idt25" data-id="956">如图是本次预测的W32B144M2B1的测试集的Tcq的仿真值、预测值以及预测准确度。对39组Tcq的预测准确度进行求平均值，得到本次学习的平均预测准确度为99.68%。从表中也可以看出所有Tcq的预测准确度均处于99%以上，预测效果很好。</p><p class="text-idt25" data-id="957">图5-13三个目标Instances测试集的全时序预测平均准确度</p><p class="text-idt25" data-id="958">上图为 W32 B144 M2 B1、 W512 B8 M2 B1和 W512 B144 M2 B1的测试集的所有时序的平均准确度折线图。从折线图中可以观察到三组 Instance的测试集在39组 PVT Corners下的时序的平均准确度都处于95%以上，其中 W32 B144 M2 B1和 W512 B144 M2 B1的 Tas、 Tws的预测平均准确度约为97%， W512 B8 M2 B1的 Tds的预测平均准确度约为95%，除此之外所有的平均准确度都达到98.5%以上，而且大部分的时序的预测平均准确度可以达到99%。</p><p class="text-idt25" data-id="959">方法三：</p><p class="text-idt25" data-id="960">通过 W32 B8 M2 B1和 W32 B144 M2 B1的8组 corners时序数据作为训练集，其中 W32 B8 M2 B1的8组 corners时序数据作为训练集的特征，而 W32 B144 M2 B1的8个 corners时序数据作为训练集的目标。 W32 B8 M2 B1和 W32 B144 M2 B1的剩余37组时序数据作为测试集，其中 W32 B8 M2 B1的37组时序数据作为测试集的特征， W32 B144 M2 B1的37组时序数据作为测试集的目标。使用最小二乘法对训练集特征和目标进行拟合，然后测试集的特征作为输入，得到测试集的目标预测值，并与测试集的目标真实值进行对比。</p><p class="text-idt25" data-id="961">本方法中的训练集的8组 Corners分别是 FG0 P81 VN40 C、 FG0 P99 VN40 C、 FG0 P9 V25 C、 TT0 P9 VN40 C、 TT0 P9 V125 C、 SG0 P81 VN40 C、 SG0 P99 VN40 C和 SG0 P9 V125 C。</p><p class="text-idt25" data-id="962">图5-14W32B144M2B1的测试集目标Tcq的仿真值、预测值以及预测准确度</p><p class="text-idt25" data-id="963">如图是本次预测的W32B144M2B1的测试集的Tcq的仿真值、预测值以及预测准确度。对37组Tcq的预测准确度进行求平均值，得到本次学习的平均预测准确度为99.64%。从表中也可以看出所有Tcq的预测准确度均处于98.8%以上，预测效果很好。</p><p class="text-idt25" data-id="964">图5-15三个目标Instances测试集的全时序预测平均准确度</p><p class="text-idt25" data-id="965">上图为 W32 B144 M2 B1、 W512 B8 M2 B1和 W512 B144 M2 B1的测试集的所有时序的平均准确度折线图。从折线图中可以观察到三组 Instance的测试集在37组 PVT Corners下的时序的平均准确度都处于96%以上，其中 W32 B144 M2 B1和 W512 B144 M2 B1的 Tas的预测平均准确度约为97.5%， W512 B8 M2 B1的 Tds的预测平均准确度约为96%，除此之外所有的平均准确度都达到98.5%以上，而且大部分的时序的预测平均准确度可以达到99%。</p><p class="text-idt25" data-id="966">方法比较</p><p class="text-idt25" data-id="967">在以上三个方法中，都是通过某一确定 Input slew和 output loading的 Instance的时序仿真数据，以及目标 Instance的部分 corners的时序仿真数据，通过最小二乘法进行回归训练，并通过训练模型进行测试集的预测。</p><p class="text-idt25" data-id="968">在以上三个方法中，方法一是用8个 corners进行训练集范围内部预测，方法二使用6个 corners进行训练集范围内部预测，方法三通过8个 corners进行全 corners范围预测。三种方法的Tcq预测准确度的最小值分别是99.05%、99.05%、98.77。三种方法的所有时序的预测平均准确度的最小值分别是96.99%、95.31%、96.24%。</p><p class="text-idt25" data-id="969">从 Tcq的准确度和全时序的平均准确度来看，方法一适用于有较多 corners仿真数据的目标 Instance，且已有 corners是处于 PVT corners的边缘，并对预测时序数据有非常高准确度和精确度的情况；方法二适用于有较少 corners仿真数据的目标 Instance，且已有 corners是处于 PVT corners的边缘，并对预测时序数据有比较高的准确度和精确度的情况；方法三适用于有较多 corners仿真数据的目标 Instance，且已有 corners不是处于 PVT corners的边缘，并对预测时序数据有非常高准确度和精确度的情况。</p><p class="text-idt25" data-id="970">由此可以得出结论：本方法在 TSMC28 nm工艺下某一确定的 Input slew和 output loading的某一 Instance的时序仿真数据，实现其他 Instance的时序仿真数据的预测，提供了三种使用不同情况的预测方法，且三种方法都可以得到准确度很高的时序仿真数据。</p><p class="text-idt25" data-id="971">以本套SRAM Compiler为例，以50个Intel（R） Xeon 频率为3.60MHZ的4核CPU，其全corners时序表征仿真工作量需要大致340天。在本时序预测方法应用于仿真工作中，本套SRAM Compiler全部仿真数据获得大概为120小时。缩减了约65%的仿真时间。由此可见，本时序预测方法可以很有成效的减少仿真工作量，同时节省仿真时间和仿真资源。</p><p class="text-idt25" data-id="972">5.2功率</p><p class="text-idt25" data-id="973">5.2.1 功率数据</p><p class="text-idt25" data-id="974">图5-16CK、A、DI的波形示意图</p><p class="text-idt25" data-id="975">如图，读电流的测量时间从 CK的下降沿到下一个下降沿，在读周期中只有 DI、 A、 CK在翻转，其他的 Pin都是 standby，且 A和 DI应该变化两次。</p><p class="text-idt25" data-id="976">写电流的测量时间从 CK的下降沿到 CK的下一个下降沿，在写周期中只有 DI、 A、 CK在翻转，其他的 Pin都处于 standby，且 A和 DI都翻转两次。</p><p class="text-idt25" data-id="977">在 light sleep mode、 deep sleep mode和 shut down mode下，所有的 Pin都保持原值，然后在分别在 light sleep、 deep sleep和 shut down的最后几个周期，选择两个周期测量。</p><p class="text-idt25" data-id="978">在功耗中主要需要采集的功率数据主要有：</p><p class="text-idt25" data-id="979">dc：standby状态下的电流的平均值</p><p class="text-idt25" data-id="980">ac_read：读操作电流平均值</p><p class="text-idt25" data-id="981">ac_write：写操作电流平均值</p><p class="text-idt25" data-id="982">ls：light sleep模式下电流平均值</p><p class="text-idt25" data-id="983">ds：deep sleep模式下电流平均值</p><p class="text-idt25" data-id="984">sd：shut down模式下电流平均值</p><p class="text-idt25" data-id="985">通常为了节省功耗和减少数据读取时间，存储器中的字数会远远多于每个字存储的位数，这样会使得存储器变得长而窄，因为位线过长会增加数据访问的速度。字深的长度和位长的大小对功率也有同样的影响。本方法考虑到样本的多样性，以及数据的差异性，采用4个形状各异的instance作为训练集，如图上上： W32 B8 M2 B1、 W32 B144 M2 B1、 W512 B8 M2 B1和 W512 B144 M2 B1分别是字长的极大值和极小值、位深的极大值和极小值的组合，也就代表了不同字长、位深对于功耗大小响应的极致体现。</p><p class="text-idt25" data-id="986">本方法共采集了18个instance的全corner仿真数据，通过程序处理和运算得到每组仿真数据分别为6个参数。共得到18组456的数据集。鉴于功率参数的复杂性，本方法的训练集采用4个 instance的数据集，以其他14个 instance的数据作为测试集，分别进行了14次回归学习和预测。分别是 W80 B8 M2 B1、 W128 B8 M2 B1、 W192 B8 M2 B1、 W256 B8 M2 B1、 W320 B8 M2 B1、 W384 B8 M2 B1、 W448 B8 M2 B1、 W80 B144 M2 B1、 W128 B144 M2 B1、 W192 B144 M2 B1、 W256 B144 M2 B1、 W320 B144 M2 B1、 W384 B144 M2 B1、 W448 B144 M2 B1等14个 Instances。</p><p class="text-idt25" data-id="987">因为功率参数受驱动电压波动的影响会有很明显的波动，通常在仿真阶段 SRAM Compiler会选择三种电压作为仿真基准电压，分别是 HVT（ High Voltage Threshold）、 SVT（ Standard Voltage Threshold）和 LVT（ Low Voltage Threshold）。通常功耗会随着阈值电压的增加而减少，就是相同条件下，HVT的功耗最小，LVT的功耗最大。</p><p class="text-idt25" data-id="988">5.2.2 功率预测</p><p class="text-idt25" data-id="989">以SVT为阈值电压进行TSMC28nm工艺SRAM Compiler全特征的功耗仿真。</p><p class="text-idt25" data-id="990">图5-17SVT下W512B8M2B1_12BIMP的全corners的DC电流值分布图</p><p class="text-idt25" data-id="991">从图中可以看出图表中根据不同温度的DC数值在不同的量级，变化差异较大，故在此预测方法中对数据进行按温度分组进行回归学习与预测。</p><p class="text-idt25" data-id="992">本方法将不同的温度分开进行学习。以W80B8M2B1为目标例，</p><p class="text-idt25" data-id="993">125</p><p class="text-idt25" data-id="994">本次回归学习中，训练集Instances的功率数据作为特征，测试集W80B8M2B1的功率数据作为目标。其中训练集Instances的5组corners的数据作为训练集的特征，另外10组corners的数据作为测试集的特征；测试集W80B8M2B1的5组corners的数据作为训练集的目标，另外10组数据作为测试集的目标。使用最小二乘法对训练集特征和目标进行回归拟合，然后将测试集的特征作为输入，得到测试集的目标预测值，并与测试集的目标真实值进行对比。</p><p class="text-idt25" data-id="995">本方法中的训练集的5组 Corners分别是 FG0 P72 V125 C、 FG1 P08 V125 C、 TT0 P9 V125 C、 SG0 P72 V125 C、 SG1 P08 V125 C。</p><p class="text-idt25" data-id="996">图5-18W80B8M2B1的测试集目标DC的仿真值、预测值以及预测准确度</p><p class="text-idt25" data-id="997">如图是本次预测的W80B8M2B1的测试集的DC的仿真值、预测值以及预测准确度。对10组DC的预测准确度进行求平均值，得到本次学习的平均预测准确度为99.38%。从表中也可以看出所有DC的预测准确度均处于98.5%以上，预测效果很好。</p><p class="text-idt25" data-id="998">图5-1914个目标Instances测试集的全功率预测平均准确度</p><p class="text-idt25" data-id="999">上图为目标Instances测试集所有功率数据的平均准确度折线图。从折线图中可以观察到14组 Instances的测试集在10组 PVT Corners下功率数据的平均准确度都处于95.5%以上，其中所有 Instances在 AC_ read和 AC_ write处的预测平均准确度约为95.5%-96.5%，在 DC和 LS处的预测平均准确度约为99.6%，在 DS和 SD处的预测平均准确度分布在97%-99.5%之间。</p><p class="text-idt25" data-id="1000">25</p><p class="text-idt25" data-id="1001">本次回归学习中，训练集Instances的功率数据作为特征，测试集W80B8M2B1的功率数据作为目标。其中训练集Instances的5组corners的数据作为训练集的特征，另外10组corners的数据作为测试集的特征；测试集W80B8M2B1的5组corners的数据作为训练集的目标，另外10组数据作为测试集的目标。使用最小二乘法对训练集特征和目标进行回归拟合，然后将测试集的特征作为输入，得到测试集的目标预测值，并与测试集的目标真实值进行对比。</p><p class="text-idt25" data-id="1002">本方法中的训练集的5组 Corners分别是 FG0 P72 V25 C、 FG1 P08 V25 C、 TT0 P9 V25 C、 SG0 P72 V25 C、 SG1 P08 V25 C。</p><p class="text-idt25" data-id="1003">如图是本次预测的W80B8M2B1的测试集的DC的仿真值、预测值以及预测准确度。对10组DC的预测准确度进行求平均值，得到本次学习的平均预测准确度为98.44%。从表中也可以看出所有DC的预测准确度均处于97.5%以上，预测效果很好。</p><p class="text-idt25" data-id="1004">图5-20W80B8M2B1的测试集目标DC的仿真值、预测值以及预测准确度</p><p class="text-idt25" data-id="1005">图5-2114个目标Instances测试集的全功率预测平均准确度</p><p class="text-idt25" data-id="1006">上图为目标Instances测试集所有功率数据的平均准确度折线图。从折线图中可以观察到14组 Instances的测试集在10组 PVT Corners下功率数据的平均准确度都处于96%以上，其中所有 Instances在 AC_ read和 AC_ write处的预测平均准确度约为99.6%，在 DC和 LS处的预测平均准确度约为98.5%～99.5%，在 DS和 SD处的预测平均准确度分布在96%～99.5%之间。</p><p class="text-idt25" data-id="1007">-40</p><p class="text-idt25" data-id="1008">本次回归学习中，训练集Instances的功率数据作为特征，测试集W80B8M2B1的功率数据作为目标。其中训练集Instances的5组corners的数据作为训练集的特征，另外10组corners的数据作为测试集的特征；测试集W80B8M2B1的5组corners的数据作为训练集的目标，另外10组数据作为测试集的目标。使用最小二乘法对训练集特征和目标进行回归拟合，然后将测试集的特征作为输入，得到测试集的目标预测值，并与测试集的目标真实值进行对比。</p><p class="text-idt25" data-id="1009">本方法中的训练集的5组 Corners分别是 FG0 P72 VN40 C、 FG1 P08 VN40 C、 TT0 P9 VN40 C、 SG0 P72 VN40 C、 SG1 P08 VN40 C。</p><p class="text-idt25" data-id="1010">图5-22W80B8M2B1的测试集目标DC的仿真值、预测值以及预测准确度</p><p class="text-idt25" data-id="1011">如图是本次预测的W80B8M2B1的测试集的DC的仿真值、预测值以及预测准确度。对10组DC的预测准确度进行求平均值，得到本次学习的平均预测准确度为99.81%。从表中也可以看出所有DC的预测准确度均处于99.5%以上，预测效果很好。</p><p class="text-idt25" data-id="1012">图5-2314个目标Instances测试集的全功率预测平均准确度</p><p class="text-idt25" data-id="1013">上图为目标Instances测试集所有功率数据的平均准确度折线图。从折线图中可以观察到14组 Instances的测试集在10组 PVT Corners下功率数据的平均准确度都处于99.2%以上，其中所有 Instances在 AC_ read和 AC_ write处的预测平均准确度约为99.7%，在 DC和 LS处的预测平均准确度约为99.5%～99.9%，在 DS和 SD处的预测平均准确度分布在99.2%～99.9%之间。</p><p class="text-idt25" data-id="1014">从以上SVT作为阈值电压的功耗数据预测中，针对Process corners的温度不同进行了分组学习。 W80 B8 M2 B1中功耗 DC在125、25、-40时的最小预测准确度分别是98.5%、97.5%、99.5%；由此我们可以推测本预测方法在预测 W80 B8 M2 B1的6个功耗参数的准确度都很高，并以此为据，进行了14个目标 Instances的仿真，分别得到125、25、-40时每组的6个功耗数据的平均预测准确度，其最小平均预测准确度分别是95.5%、96%、99.2%。从预测平均准确度的结果来看，本方法应用于 TSMC28 nm工艺的 SRAM Compiler的表征功耗数据的预测具有很高的准确度，表明了通过最小二乘法进行回归学习与预测功耗数据的可行性与准确性。</p><p class="text-idt25" data-id="1015">以本套SRAM Compiler为例，以50个Intel（R） Xeon 频率为3.60MHZ的4核CPU，其全corners功耗表征仿真工作量需要大致720小时。在本功耗预测方法应用于仿真工作中，本套SRAM Compiler全部仿真数据获得大概需要200小时。缩减了约72%的仿真时间。由此可见，本时序预测方法可以很有成效的减少仿真工作量，同时节省仿真时间和仿真资源。</p><p class="text-idt25" data-id="1016">5.3本章小结</p><p class="text-idt25" data-id="1017">本章首先介绍了读操作、写操作和电源模式的时序含义，提出了两种时序预测方法：相同Instances预测、不同Instances预测。其中相同Instances预测可以实现预测相同Instances不同Input slew和output loading的时序数据；不同Instance预测提供三种方法实现相同Input slew和output loading的不同Instances的时序数据预测。且以上方法都能达到97%和95.5%以上的预测平均准确度。并且分析了应用本方法后本SRAM Compiler的时序仿真能节省65%的仿真时间。</p><p class="text-idt25" data-id="1018">本章的第二部分介绍了功率参数的含义，提出了基于温度分类的功率参数分类方法，且本方法能达到至少95.2%、96%、99.2%的预测平均准确度。并分析了应用本方法后本SRAM Compiler的功耗仿真能节省72%的仿真时间。</p><p class="text-idt25" data-id="1019">第六章总结与展望</p><p class="text-idt25" data-id="1020">6.1 论文总结</p><p class="text-idt25" data-id="1021">现代 SOC应用场景的不断拓展，对 SOC不同的需求被提出，存储器作为 SOC的重要部分，也对存储器提出了极高的要求，其中使用的 SRAM在此背景下需要不断提升以适用于不同的需求，在各种高速、低功耗技术不断被提出的状态下，其对本身就很复杂耗时的 SRAM表征环节提出了更高的要求。</p><p class="text-idt25" data-id="1022">本文以UMC28nmHLP工艺的标准单元库为例，提出了两种应用于标准单元库的时序预测方法：电路参数预测方法和时序预测方法。使用最小二乘回归算法预测了标准单元电路的时序，其中电路参数方法的预测时序的准确度能达到87.36%；时序方法的预测时序的准确度能达到98.68%。并从时间成本和机器资源成本对两种方法进行了评估，电路参数方法节约时间大致有30%，时序方法节约时间大致有50%。</p><p class="text-idt25" data-id="1023">以标准单元库时序预测的可行性为出发点，本文还提出了针对SRAM Compiler表征的数据预测方法。</p><p class="text-idt25" data-id="1024">本文还介绍了 SRAM的基本框架和基本电路结构，针对影响表征仿真工作量的所有参数特征、 word、 bit、 mux、 bank、 input slew、 output loading和 PVT corners等进行了详细的阐述，针对不同仿真的需求：相同Instance不同Input slew和output loading之间的预测、相同input slew和output loading下不同Instance之间的预测。对两种需求分别提出了一种和三种预测方法，其中针对不同instance之间预测的三种方法分别具有不同的应用场景。从预测结果来看，相同Instance预测方法能达到最低97%的平均准确度；不同Instance预测方法分别能达到最低96.99%、95.31%、96.24%的平均准确度。从时间成本个机器成本进行了评估，本时序预测方法能节省仿真时间大约67%。</p><p class="text-idt25" data-id="1025">最后对 SRAM Compiler表征的功耗数据也提出了一种基于温度分类的功率参数分类方法，三个温度段的预测方法能达到至少95.2%、96%、99.2%的预测平均准确度。并分析了应用本方法后本SRAM Compiler的功耗仿真能节省73%的仿真时间。</p><p class="text-idt25" data-id="1026">6.2 工作展望</p><p class="text-idt25" data-id="1027">本文主要的工作集中在SRAM Compiler表征的时序与功耗的预测，本文的不足以及后续工作包括：</p><p class="text-idt25" data-id="1028">本课题时序数据都是选取全特征的Instance，未对单个或多个Instance特征进行仿真与预测工作，接下来会对这部分进行研究。</p><p class="text-idt25" data-id="1029">本课题功耗数据中只针对SVT下的功耗数据进行了预测工作，将来需要对HVT和LVT下的功耗数据进行预测研究。</p><p class="text-idt25" data-id="1030">本文采用TSMC28nmHPC+工艺的SRAM Compiler进行了表征数据预测，接下来还需要针对不同工艺的SRAM Compiler进行表征数据的预测。</p>        <div class="paper-footer">
            <p>检测报告由<a href="http://www.paperpass.com/" target="_black">PaperPass</a>文献相似度检测系统生成</p>
            <p>Copyright © 2007-2018 PaperPass</p>
        </div>
    </div>

</div>
</body>
<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/Lib.js"></script>
<script type="text/javascript">
    Report.report_id = '5ac9cc0f648cc5lk6';
</script>
<script type="text/javascript">
    (function(System,$){
        var cache = new System.Cache(System.report_id,localStorage);
        $(function(){
            $.each(cache.get(),function(){
                $('[data-id='+this.id+']').addClass('g-font-color green').html(this.text);
            });

        });
    })(Report,jQuery);

</script>
</html>
